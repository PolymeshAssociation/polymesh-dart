---
layout: default
title: Fee System
---

## Fee

Fee accounts are different from regualar accounts and their states are tracked in a different curve tree. Fee accounts also transition from one state to another, invalidating old state by revealing the nullifier. Fee can be paid in designated assets and these are different from non-fee paying assets. These assets don't have auditors or mediators. Fee accounts support minting and spend. During both the amount minted or spent is public but the balance of new state is kept private. Also, for fee payment asset-id is always revealed. Nullifier secret key $\rho$ and commitment randomness $s$ are not generated deterministically but chosen randomly. They don't have an id or counter. Following shows a state transition in fee account.

$$
State_{old} = sk.G_{Aff} + balance.G_1 + at.G_3 + \rho.G_5 + s.G_6, \quad State_{old} \in \mathbb{G}_p
$$

$$
State_{new} = sk.G_{Aff} + balance'.G_1 + at.G_3 + \rho'.G_5 + s'.G_6, \quad State_{new} \in \mathbb{G}_p
$$


### Account registration
A user can register fee account with a non-zero balance. The asset-id, balance and public key are public during registration.
A successful completion of registration results in the following:
1. A state $State_0$ being inserted as a leaf in the accounts curve tree where
   $$
   State_0 = sk.G_{Aff} + balance.G_1 + at.G_3 + \rho.G_5 + s.G_6
   $$
2. Pair asset-id, public key $(asset\_id$, $PK_{Aff}(=sk.G_{Aff}))$ is added to the Asset-account mapping

#### Protocol
Here the prover (investor) wants to prove following relations:
1. $State_0 = sk.G_{Aff} + balance.G_1 + at.G_3 + \rho.G_5 + s.G_6$. This is equivalent to proving $State_0 - AK - balance.G_1 - at.G_3 = \rho.G_5 + s.G_6$ since $AK, balance, at$ are revealed to the verifier.
2. $AK = sk.G_{Aff}$

##### Prover

1. Prover wants to prove knowledge of $\rho, s$ in the relation $\rho.G_5 + s.G_6 = State_0 - AK - balance.G_1 - at.G_3$ where the RHS is public.
2. Similarly, prover wants to prove knowledge of $sk$ in $AK = sk.G_{Aff}$.
3. Prover picks random $sk_{blinding}, \rho_{blinding}, s_{blinding} \in \mathbb{Z}_p$ and creates:
   $$
   T_{state} = \rho_{blinding}.G_5 + s_{blinding}.G_6, \in \mathbb{G}_p
   $$
4. For proving knowledge of secret key, prover creates:
   $T_{pk} = sk_{blinding}.G_{Aff}, \in \mathbb{G}_p$
5. Prover hashes the following to create challenge $c$ as:
   $c = Hash(State_0, AK, balance, at, T_{state}, T_{pk})$
6. Prover creates responses for $Resp_{state}$:
   $$Resp_{state} = [\begin{matrix}
   \rho_{blinding} + \rho.c, & s_{blinding} + s.c\\
   \end{matrix}]$$
7. Response for secret key:
   $Resp_{pk} = sk_{blinding} + sk.c$
8. The proof is
   $$
   (State_0, AK, balance, at, T_{state}, T_{pk}, Resp_{state}, Resp_{pk})
   $$


##### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $c = Hash(State_0, AK, balance, at, T_{state}, T_{pk})$
2. Verifies correctness of $State_0$ by checking:
   $$Resp_{state}[0].G_5 + Resp_{state}[1].G_6 \stackrel{?}{=} T_{state} + (State_0 - AK - balance.G_1 - at.G_3).c$$

$$\implies (\rho_{blinding} + \rho.c).G_5 + (s_{blinding} + s.c).G_6 \stackrel{?}{=} T_{state} + (State_0 - AK - balance.G_1 - at.G_3).c$$

3. Verifies knowledge of secret key by checking:
   $Resp_{pk}.G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$
   $\implies (sk_{blinding} + sk.c).G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$


### Account top-up
This is similar to regular account's minting txn where the balance in $State_{new}$ is increased by a public amount $v$ and the public key $sk.G_{Aff}$ is revealed as well.

A successful completion of top-up txn results in the following:
1. The user's old account state $State_{old}$ is invalidated and new state $State_{new}$ is created. However, $State_{old}$ cannot be revealed as it identifies which account state is being invalidated. So a randomized version of it $State_{{old}_r}$ is used in relations.
2. Nullifier $N=\rho.G_5$ is revealed by issuer and chain adds it to the nullifier set. Here $\rho$ refers to the nullifier secret key of $State_{old}$
3. The balance in $State_{new}$ is more than balance in $State_{old}$ by the minted amount
4. $State_{new}$ is inserted as a new leaf in the curve tree.

#### Protocol
Here the prover (user) wants to prove following relations when minting amount $v$:
1. $State_{old} = sk.G_{Aff} + bal_0.G_1 + at.G_3 + \rho.G_5 + s^j.G_6$. This is equivalent to proving $State_{old} = AK + bal_0.G_1 + at.G_3 + \rho.G_5 + s^j.G_6$ since public key $AK$ is revealed to the verifier. Since $bal_0 + v = bal_1$, this is equivalent to $State_{old} + v.G_1 = AK + bal_1.G_1 + at.G_3 + \rho.G_5 + s^j.G_6$
2. Similarly $State_{new} = AK + bal_1.G_1 + at.G_3 + \rho'.G_5 + s'.G_6$.
3. $State_{old}$ exists in the accumulator (account curve tree)
4. $N = \rho.G_5$
5. $AK = sk.G_{Aff}$
6. $bal_1 = bal_0 + v$
7. $bal_1 <= MAX\_FEE\_BALANCE$

**Instance**: $State_{{old}_r}, State_{new}, AK, at, N, v, Path_r, Root, G_{Aff}, G_i, H_i$

**Witness**: $sk, bal_0, bal_1, \rho, \rho', s, s', Path$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

##### Prover

1. Prover wants to prove knowledge of $bal_1, \rho, s$ in the relation $bal_1.G_1 + \rho.G_5 + s.G_6 = State_{{old}_r} + v.G_1 - AK - at.G_3$.
2. Similarly, prover wants to prove knowledge of $bal_1, \rho', s'$ in $bal_1.G_1 + \rho'.G_5 + s'.G_6 = State_{new} - AK - at.G_3$ where the RHS is public.
3. Prover gets the path of the leaf $State_{old}$ as $Path$, an array of nodes (curve points), and randomizes it by adding blindings to all nodes. This will result in the leaf $State_{old}$ being transformed into $State_{{old}_r} = State_{old} + b_0.H_0$ and $Path$ transforms into $Path_r$. Prover enforces the constraints for curve tree membership using $Path, Path_r, b_i$.
4. Since prover knows the opening of $State_{old}$ and $b_0$, it can prove the knowledge of opening of $State_{{old}_r}$ as well. So relation 1 can be transformed as:
   $$
   bal_1.G_1 + \rho.G_5 + s.G_6 + b_0.H_0 = State_{{old}_r} + v.G_1 - AK - at.G_3
   $$
   where the RHS is public.
5. Prover picks random $sk_{blinding}, bal_{1_{blinding}}, \rho_{blinding}, \rho'_{blinding}, s_{blinding}, s'_{blinding}, b_{0_{blinding}} \in \mathbb{Z}_p$ and creates:
   $$
   T_{State_{{old}_r}} = bal_{1_{blinding}}.G_1 + \rho_{blinding}.G_5 + s_{blinding}.G_6 + b_{0_{blinding}}.H_0, \in \mathbb{G}_p
   $$
6. For the new state, create:
   $$
   T_{State_{new}} = bal_{1_{blinding}}.G_1 + \rho'_{blinding}.G_5 + s'_{blinding}.G_6, \in \mathbb{G}_p
   $$
   Same blinding $bal_{1_{blinding}}$ is used for both old and new state as the equation of $State_{{old}_r}$ has been adjusted to keep balance witness same.
7. For the correctness of nullifier and knowledge of secret key, prover creates:
   $T_{null} = \rho_{blinding}.G_5, \in \mathbb{G}_p$
   $T_{pk} = sk_{blinding}.G_{Aff}, \in \mathbb{G}_p$
8. For enforcing $bal_1 <= MAX\_FEE\_BALANCE$, prover sets up constraints in Bulletproof. Let $C_{BP_{bal}}$ be the commitment:
   $$
   C_{BP_{bal}} = b'.H_0 + bal_1.H_1, \in \mathbb{G}_p
   $$

9. Prover creates commitment for $C_{BP_{bal}}$ by picking random $r_{BP_{bal}} \in \mathbb{Z}_p$:
   $$
   T_{BP_{bal}} = r_{BP_{bal}}.H_0 + bal_{1_{blinding}}.H_1, \in \mathbb{G}_p
   $$

10. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_{{old}_r}, State_{new}, AK, at, N, v, Path_r, Root, C_{BP_{bal}}, T_{State_{{old}_r}}, T_{State_{new}}, T_{null}, T_{pk}, T_{BP_{bal}})
    $$

11. Prover creates responses for $Resp_{state_{old_r}}$:
    $$Resp_{state_{old_r}} = [\begin{matrix}
    bal_{1_{blinding}} + bal_1.c, & \rho_{blinding} + \rho.c, & s_{blinding} + s.c, & b_{0_{blinding}} + b_0.c\\
    \end{matrix}]$$

12. Prover creates responses for $Resp_{state_{new}}$:
    $$Resp_{state_{new}} = [\begin{matrix}
    \bot, & \rho'_{blinding} + \rho'.c, & s'_{blinding} + s'.c\\
    \end{matrix}]$$
    The symbol $\bot$ indicates that no response is created for $bal_1$ since a response has been created for the same witness in $Resp_{state_{old_r}}$.

13. Response for nullifier:
    $Resp_{null} = \rho_{blinding} + \rho.c$

14. Response for secret key:
    $Resp_{pk} = sk_{blinding} + sk.c$

15. For relation $C_{BP_{bal}}$, only the response for blinding $b'$ needs to be created:
    $Resp_{b'} = r_{BP_{bal}} + b'.c$

16. The proof is
    $$
    (C_{BP_{bal}}, State_{{old}_r}, State_{new}, Path_r, N, T_{State_{{old}_r}}, T_{State_{new}}, T_{null}, T_{pk}, T_{BP_{bal}}, Resp_{state_{old_r}}, Resp_{state_{new}}, Resp_{null}, Resp_{pk}, Resp_{b'})
    $$


##### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$c = Hash(State_{{old}_r}, State_{new}, AK, at, N, v, Path_r, Root, C_{BP_{bal}}, T_{State_{{old}_r}}, T_{State_{new}}, T_{null}, T_{pk}, T_{BP_{bal}})
   $$

2. Verifier enforces the Bulletproof constraint for the balance change: $bal_1 <= MAX\_FEE\_BALANCE$. (Constraints in the appendix)

3. Verifier enforces the Bulletproof constraints for curve tree membership to verify that $Path_r$ leads to $Root$. (Constraints in the appendix)

4. Verifies correctness of $State_{{old}_r}$ by checking:
   $$Resp_{state_{old_r}}[0].G_1 + Resp_{state_{old_r}}[1].G_5 + Resp_{state_{old_r}}[2].G_6 + Resp_{state_{old_r}}[3].H_0 \stackrel{?}{=} T_{State_{{old}_r}} + (State_{{old}_r} + v.G_1 - AK - at.G_3).c$$

$$\implies (bal_{1_{blinding}} + bal_1.c).G_1 + (\rho_{blinding} + \rho.c).G_5 + (s_{blinding} + s.c).G_6 + (b_{0_{blinding}} + b_0.c).H_0 \stackrel{?}{=} T_{State_{{old}_r}} + (State_{{old}_r} + v.G_1 - AK - at.G_3).c$$

5. Verifies correctness of $State_{new}$ by checking:
   $$Resp_{state_{old_r}}[0].G_1 + Resp_{state_{new}}[1].G_5 + Resp_{state_{new}}[2].G_6 \stackrel{?}{=} T_{State_{new}} + (State_{new} - AK - at.G_3).c$$

$$\implies (bal_{1_{blinding}} + bal_1.c).G_1 + (\rho'_{blinding} + \rho'.c).G_5 + (s'_{blinding} + s'.c).G_6 \stackrel{?}{=} T_{State_{new}} + (State_{new} - AK - at.G_3).c$$

Note that for the $bal_1$ component, verifier reuses the response from $Resp_{state_{old_r}}$ as indicated by $\bot$ in $Resp_{state_{new}}$.

6. Verifies correctness of nullifier by checking:
   $Resp_{null}.G_5 \stackrel{?}{=} T_{null} + N.c$
   $\implies (\rho_{blinding} + \rho.c).G_5 \stackrel{?}{=} T_{null} + N.c$

7. Verifies knowledge of secret key by checking:
   $Resp_{pk}.G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$
   $\implies (sk_{blinding} + sk.c).G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$

8. Verifier checks response for $C_{BP_{bal}}$ as:
   $Resp_{b'}.H_0 + Resp_{state_{old_r}}[0].H_1 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$

$\implies (r_{BP_{bal}} + b'.c).H_0 + (bal_{1_{blinding}} + bal_1.c).H_1 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$

9. Verifier finally checks the Bulletproofs proof for all constraints i.e. curve tree membership and balance change


### Fee payment
To pay of amount $v$, the old account state is transitioned to a new one whose balance is $v$ less than the previous one. The user must always reveal the asset-id for fee.

A successful completion of fee payment results in the following:
1. The user's old account state $State_{old}$ is invalidated and new state $State_{new}$ is created. However, $State_{old}$ cannot be revealed as it identifies which account state is being invalidated. So a randomized version of it $State_{{old}_r}$ is used in relations.
2. Nullifier $N=\rho.G_5$ is revealed by issuer and chain adds it to the nullifier set. Here $\rho$ refers to the nullifier secret key of $State_{old}$
3. The balance in $State_{new}$ is less than balance in $State_{old}$ by the fee amount
4. $State_{new}$ is inserted as a new leaf in the curve tree.

#### Protocol
Here the prover (user) wants to prove following relations when minting amount $v$:
1. $State_{old} = sk.G_{Aff} + bal_0.G_1 + at.G_3 + \rho.G_5 + s^j.G_6$. Since $bal_0 - v = bal_1$, this is equivalent to $State_{old} + v.G_1 = sk.G_{Aff} + bal_1.G_1 + at.G_3 + \rho.G_5 + s^j.G_6$
2. Similarly $State_{new} = sk.G_{Aff} + bal_1.G_1 + at.G_3 + \rho'.G_5 + s'.G_6$.
3. $State_{old}$ exists in the accumulator (account curve tree)
4. $N = \rho.G_5$
5. $bal_1 = bal_0 - v$
6. $bal_1 <= MAX\_FEE\_BALANCE$

**Instance**: $State_{{old}_r}, State_{new}, at, N, v, Path_r, Root, G_{Aff}, G_i, H_i$

**Witness**: $sk, bal_0, bal_1, \rho, \rho', s, s', Path$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

#### Prover

1. Prover wants to prove knowledge of $sk, bal_1, \rho, s$ in the relation $bal_1.G_1 + \rho.G_5 + s.G_6 = State_{{old}_r} + v.G_1 - at.G_3 - sk.G_{Aff}$.
2. Similarly, prover wants to prove knowledge of $sk, bal_1, \rho', s'$ in $bal_1.G_1 + \rho'.G_5 + s'.G_6 = State_{new} - at.G_3 - sk.G_{Aff}$ where the RHS is public.
3. Prover gets the path of the leaf $State_{old}$ as $Path$, an array of nodes (curve points), and randomizes it by adding blindings to all nodes. This will result in the leaf $State_{old}$ being transformed into $State_{{old}_r} = State_{old} + b_0.H_0$ and $Path$ transforms into $Path_r$. Prover enforces the constraints for curve tree membership using $Path, Path_r, b_i$.
4. Since prover knows the opening of $State_{old}$ and $b_0$, it can prove the knowledge of opening of $State_{{old}_r}$ as well. So relation 1 can be transformed as:
   $$
   sk.G_{Aff} + bal_1.G_1 + \rho.G_5 + s.G_6 + b_0.H_0 = State_{{old}_r} + v.G_1 - at.G_3
   $$
   where the RHS is public.
5. Prover picks random $sk_{blinding}, bal_{1_{blinding}}, \rho_{blinding}, \rho'_{blinding}, s_{blinding}, s'_{blinding}, b_{0_{blinding}} \in \mathbb{Z}_p$ and creates:
   $$
   T_{State_{{old}_r}} = sk_{blinding}.G_{Aff} + bal_{1_{blinding}}.G_1 + \rho_{blinding}.G_5 + s_{blinding}.G_6 + b_{0_{blinding}}.H_0, \in \mathbb{G}_p
   $$
6. For the new state, create:
   $$
   T_{State_{new}} = sk_{blinding}.G_{Aff} + bal_{1_{blinding}}.G_1 + \rho'_{blinding}.G_5 + s'_{blinding}.G_6, \in \mathbb{G}_p
   $$
   Same blindings for $sk, bal_1$ are used in both old and new state since these values don't change.
7. For the correctness of nullifier, prover creates:
   $T_{null} = \rho_{blinding}.G_5, \in \mathbb{G}_p$
8. For enforcing $bal_1 <= MAX\_FEE\_BALANCE$, prover sets up constraints in Bulletproof. Let $C_{BP_{bal}}$ be the commitment:
   $C_{BP_{bal}} = b'.H_0 + bal_1.H_1, \in \mathbb{G}_p$
9. Prover creates commitment for $C_{BP_{bal}}$ by picking random $r_{BP_{bal}} \in \mathbb{Z}_p$:
   $T_{BP_{bal}} = r_{BP_{bal}}.H_0 + bal_{1_{blinding}}.H_1, \in \mathbb{G}_p$
10. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_{{old}_r}, State_{new}, at, N, v, Path_r, Root, C_{BP_{bal}}, T_{State_{{old}_r}}, T_{State_{new}}, T_{null}, T_{BP_{bal}})
    $$
11. Prover creates responses for $Resp_{state_{old_r}}$:
    $$Resp_{state_{old_r}} = [\begin{matrix}
    sk_{blinding} + sk.c, & bal_{1_{blinding}} + bal_1.c, &  \rho_{blinding} + \rho.c, & s_{blinding} + s.c, & b_{0_{blinding}} + b_0.c\\
    \end{matrix}]$$

12. Prover creates responses for $Resp_{state_{new}}$:
    $$Resp_{state_{new}} = [\begin{matrix}
    \bot, & \bot, & \rho'_{blinding} + \rho'.c, & s'_{blinding} + s'.c\\
    \end{matrix}]$$
    The symbol $\bot$ indicates that no response is created for $sk, bal_1$ since responses have been created for the same witnesses in $Resp_{state_{old_r}}$.

13. Response for nullifier:
    $Resp_{null} = \rho_{blinding} + \rho.c$

14. For relation $C_{BP_{bal}}$, only the response for blinding $b'$ needs to be created:
    $Resp_{b'} = r_{BP_{bal}} + b'.c$

15. The proof is
    $$
    (C_{BP_{bal}}, State_{{old}_r}, State_{new}, Path_r, N, T_{State_{{old}_r}}, T_{State_{new}}, T_{null}, T_{BP_{bal}}, Resp_{state_{old_r}}, Resp_{state_{new}}, Resp_{null}, Resp_{b'})
    $$


#### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$c = Hash(State_{{old}_r}, State_{new}, at, N, v, Path_r, Root, C_{BP_{bal}}, T_{State_{{old}_r}}, T_{State_{new}}, T_{null}, T_{BP_{bal}})
   $$
2. Verifier enforces the Bulletproof constraint for the balance range: $bal_1 <= MAX\_FEE\_BALANCE$. (Constraints in the appendix)
3. Verifier enforces the Bulletproof constraints for curve tree membership to verify that $Path_r$ leads to $Root$. (Constraints in the appendix)
4. Verifies correctness of $State_{{old}_r}$ by checking:
   $$Resp_{state_{old_r}}[0].G_{Aff} + Resp_{state_{old_r}}[1].G_1 + Resp_{state_{old_r}}[3].G_5 + Resp_{state_{old_r}}[4].G_6 + Resp_{state_{old_r}}[5].H_0 \stackrel{?}{=} T_{State_{{old}_r}} + (State_{{old}_r} + v.G_1 - at.G_3).c$$

$$\implies (sk_{blinding} + sk.c).G_{Aff} + (bal_{1_{blinding}} + bal_1.c).G_1 + (\rho_{blinding} + \rho.c).G_5 + (s_{blinding} + s.c).G_6 + (b_{0_{blinding}} + b_0.c).H_0 \stackrel{?}{=} T_{State_{{old}_r}} + (State_{{old}_r} + v.G_1 - at.G_3).c$$

5. Verifies correctness of $State_{new}$ by checking:
   $$Resp_{state_{old_r}}[0].G_{Aff} + Resp_{state_{old_r}}[1].G_1 + Resp_{state_{new}}[3].G_5 + Resp_{state_{new}}[4].G_6 \stackrel{?}{=} T_{State_{new}} + (State_{new} - at.G_3).c$$

$$\implies (sk_{blinding} + sk.c).G_{Aff} + (bal_{1_{blinding}} + bal_1.c).G_1 + (\rho'_{blinding} + \rho'.c).G_5 + (s'_{blinding} + s'.c).G_6 \stackrel{?}{=} T_{State_{new}} + (State_{new} - at.G_3).c$$
Note that for the $sk, bal_1$ components, verifier reuses responses from $Resp_{state_{old_r}}$ as indicated by $\bot$ in $Resp_{state_{new}}$.
6. Verifies correctness of nullifier by checking:
   $Resp_{state_{old_r}}[3].G_5 \stackrel{?}{=} T_{null} + N.c$
   $\implies (\rho_{blinding} + \rho.c).G_5 \stackrel{?}{=} T_{null} + N.c$
7. Verifier checks response for $C_{BP_{bal}}$ as:
   $Resp_{b'}.H_0 + Resp_{state_{old_r}}[1].H_1 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$
   $\implies (r_{BP_{bal}} + b'.c).H_0 + (bal_{1_{blinding}} + bal_1.c).H_1 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$
8. Verifier finally checks the Bulletproofs proof for all constraints i.e. curve tree membership and balance range
