# Sender/Receiver Affirmations

## Affirmations
Once has settlement has been posted on chain, sender/receiver send their agreement along with a proof which proves that they are the party to that leg and they have done a correct account state transition, invalidating previous state by submitting the nullifier and their revealing their new state. Note that they don't point to their old state in the accumulator.

For an account state to transition from $State_{old}$ to $State_{new}$,
- secret key $sk$, identity $id$ and asset-id $at$ should not change
- nullifer should be revealed as $\rho^i.G_5$
- nullifier secret key $\rho^i$ and randomness $s^j$ should change as: $\rho^{i+1} = \rho.\rho^i$, $s^{2.j} = s^j.s^j$

Old state
$$
State_{old} = sk.G_{Aff} + balance.G_1 + counter.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7 \quad State_{old} \in \mathbb{G}_p
$$

New state
$$
State_{new} = sk.G_{Aff} + balance'.G_1 + counter'.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7 \quad State_{new} \in \mathbb{G}_p
$$

$balance$ might or might not be same as $balance'$ depending on who is affirming or what kind of transaction it is. $counter'$ might be 1 more or 1 less than $counter$ depending on the kind of transaction.
Also, it must be proved that the $State_{old}$ has same asset-id $at$ that is in the leg and has the public key for the same secret key as in the account.


For a single leg settlement of amount $v$:

1. When a sender affirms a leg, its new account state's balance should be $v$ less than the old account's and its counter should increase by 1.
2. When a receiver affirms a leg, its new account state's balance should be same as the old account's and its counter should increase by 1.
3. Sender can revert its affirmation by creating a new account state which has the balance increased by $v$ and counter decreased by 1.
4. Receiver can revert its affirmation by creating a new account state with counter decreased by 1.
5. Once a settlement has been confirmed, i.e. it cant be reverted,
    - sender can send a counter update txn to decrease its counter by 1
    - receiver can send a claim funds txn to increases its balance by $v$ and decrease its counter by 1.

Table describing changes to balance and counter for various txns. $_s$ and $_r$ refer to txn sent by sender and receiver respectively.

| Transaction Type | Description                               | Balance Change | Counter Change |
|------------------|-------------------------------------------|----------------|----------------|
| **Affirm_s**     | Sender affirms a leg of amount $v$        | **-v**         | **+1**         |
| **Affirm_r**     | Receiver affirms a leg                    | **0**          | **+1**         |
| **Claim_r**      | Receiver claims funds after settlement    | **+v**         | **-1**         |
| **CntUpd_s**     | Sender updates counter after settlement   | **0**          | **-1**         |
| **Reverse_s**    | Sender reverses their affirmation         | **+v**         | **-1**         |
| **Reverse_r**    | Receiver reverses their affirmation       | **0**          | **-1**         |


### Protocol
This section describes a unified account state transition proof which can handle all the above scenarios and parts of this proof can be omitted when balance doesn't change
Here the prover (sender/receiver) wants to prove following relations when sending affirmation for leg with amount $v$:

1. $State_{old} = sk.G_{Aff} + bal_0.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7$
2. Similarly $State_{new} = sk.G_{Aff} + bal_1.G_1 + cnt_1.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$
3. $State_{old}$ exists in the accumulator (account curve tree)
4. $N = \rho^i.G_5$
6. $\rho^{i+1} = \rho.\rho^i$
7. $s^{2.j} = s^j.s^j$
8. If balance change is expected,
    - $bal_1 = bal_0 - v$ (for **Affirm_s**)
    - $bal_1 = bal_0 + v$ (for **Claim_r** or **Reverse_s**)
9. Counter change:
    - $cnt_1 = cnt_0 + 1$ (**Affirm_s**, **Affirm_r**)
    - $cnt_1 = cnt_0 - 1$ (**Claim_r**, **CntUpd_s**, **Reverse_s**, **Reverse_r**)
10. Since the change to counter is public, relation for $State_{new}$ can be expressd as:
    - $State_{new} - G_2 = sk.G_{Aff} + bal_1.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$ if counter increased by 1.
    - $State_{new} + G_2 = sk.G_{Aff} + bal_1.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$ if counter decreased by 1.
11. $bal_1 <= MAX\_BALANCE$ to avoid overflows
12. Prove that asset id in $CT_{at}$ is $at$
13. If transition involves a balance change, prove that amount in $CT_v$ is $v$
14. Prove that $sk$ is the secret key of public key in:
    - $CT_s$ if they are sender
    - $CT_r$ if they are receiver

**Instance**: $State_{old_r}$, $State_{new}$, $N$, $Path_r$, $Root$, $CT_s$, $CT_r$, $CT_v$, $CT_{at}$, $G_{Aff}$, $G_i$, $H$, $H_i$, $\widetilde{G}$, $\widetilde{G}_i$, $\widetilde{H}$, $\widetilde{H}_i \in \mathbb{G}_q$

**Witness**: $sk, at, id, v, bal_0, bal_1, cnt, \rho, \rho^i, \rho^{i+1}, s^j, s^{2.j}, Path$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

#### Prover
1. Prover first wants to prove knowledge of $sk, at, bal_0, cnt, \rho, \rho^i, s^j, id$ in the relation $$State_{old} = sk.G_{Aff} + bal_0.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7$$
2. Similarly, prover wants to prove knowledge of $sk, at, bal_1, cnt, \rho, \rho^{i+1}, s^{2.j}, id$ in $State_{new}$ from relation 10.
    - If counter increased by 1: $$State_{new} - G_2 = sk.G_{Aff} + bal_1.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$$
    - If counter decreased by 1: $$State_{new} + G_2 = sk.G_{Aff} + bal_1.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$$
3. Prover gets the path of the leaf $State_{old}$ as $Path$, an array of nodes (curve points), and randomizes it by adding blindings to all nodes. This will result in the leaf $State_{old}$ being transformed into $State_{old_r} = State_{old} + b_0.H_0$ and $Path$ transforms into $Path_r$. Prover enforces the constraints for curve tree membership using $Path, Path_r, b_i$.
4. Since prover knows the opening of $State_{old}$ and $b_0$, it can prove the knowledge of opening of $State_{old_r}$ as well. So relation 1 can be transformed as:
   $$
   sk.G_{Aff} + bal_0.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7 + b_0.H_0 = State_{old_r}
   $$
5. Prover picks random $$sk_r, at_r,  bal_{0_r},  cnt_r, \rho_r, \rho_{i_r}, \rho_{{i+1}_r}, s^j_r, s^{2.j}_r, id_r, b_{0_{blinding}} \in \mathbb{Z}_p$$ and creates:
   $$T_{State_{old_r}} = sk_r.G_{Aff} +  bal_{0_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + $$
   $$\rho_{i_r}.G_5 + s^j_r.G_6 + id_r.G_7 + b_{0_{blinding}}.H_0, \in \mathbb{G}_p$$
6. For the new state, create:
   $$T_{State_{new}} = sk_r.G_{Aff} +  bal_{1_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + $$
   $$\rho_{{i+1}_r}.G_5 + s^{2.j}_r.G_6 + id_r.G_7, \in \mathbb{G}_p$$

   Same blindings for $sk, at, cnt, \rho, id$ are used in both old and new state since these values don't change. If balance doesn't change, also use same blinding so $ bal_{0_r} =  bal_{1_r}$.
7. For the correctness of nullifier, prover creates:
   $$
   T_{null} = \rho_{i_r}.G_5, \in \mathbb{G}_p
   $$
8. For enforcing $\rho^{i+1} = \rho.\rho^i$ and $s^{2.j} = s^j.s^j$, prover sets up the constraints in Bulletproof as both are multiplications. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of committed values in Bulletproof's commitment and in the state commitments. Let $C_{BP_{\rho,s}}$ be the commitment:
   $$
   C_{BP_{\rho,s}} = b'.H_0 + \rho.H_1 + \rho^i.H_2 + \rho^{i+1}.H_3 + s^j.H_4 + s^{2.j}.H_5, \in \mathbb{G}_p
   $$
9. If the balance changes, prover sets up constraint in Bulletproof based on transaction type:
    - If balance change is $-v$: $bal_1 = bal_0 - v$
    - If balance change is $+v$: $bal_1 = bal_0 + v$

   Let $C_{BP_{bal}}$ be the commitment:
   $$
   C_{BP_{bal}} = b''.H_0 + v.H_1 + bal_0.H_2 + bal_1.H_3, \in \mathbb{G}_p
   $$
10. Prover creates commitment for $C_{BP_{\rho,s}}$ by picking random $r_{BP_{\rho,s}} \in \mathbb{Z}_p$:
    $$
    T_{BP_{\rho,s}} = r_{BP_{\rho,s}}.H_0 + \rho_r.H_1 + \rho_{i_r}.H_2 + \rho_{{i+1}_r}.H_3 + s^j_r.H_4 + s^{2.j}_r.H_5, \in \mathbb{G}_p
    $$
11. Prover creates commitment for $C_{BP_{bal}}$ by picking random $v_{blinding}, r_{BP_{bal}} \in \mathbb{Z}_p$:
    $$
    T_{BP_{bal}} = r_{BP_{bal}}.H_0 + v_{blinding}.H_1 +  bal_{0_r}.H_2 +  bal_{1_r}.H_3, \in \mathbb{G}_p
    $$
12. For proving $at$ in $CT_{at}$, picks random $r_{4_{blinding}} \in \mathbb{Z}_p$ and creates:
    $T_{at} = r_{4_{blinding}}.G_{Enc} + at_r.H$
13. For proving the correctness of public key in leg, picks random $r_{pk_{blinding}} \in \mathbb{Z}_p$ and creates:
    $$T_{pk} = r_{pk_{blinding}}.G_{Enc} + sk_r.G_{Aff}$$
14. If balance changes, picks random $r_{3_{blinding}} \in \mathbb{Z}_p$ and creates:
    $T_v = r_{3_{blinding}}.G_{Enc} + v_{blinding}.H$
15. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_{old_r}, State_{new}, N, Path_r, Root, CT_s, CT_r, CT_v, CT_{at}, C_{BP_{\rho,s}}, C_{BP_{bal}}, $$
    $$T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{BP_{bal}}, T_{at}, T_{pk}, T_v)$$
16. Prover creates responses for $Resp_{state_{old_r}}$ =
    $$[\begin{matrix}
    sk_r + sk.c, &  bal_{0_r} + bal_0.c, &  cnt_r + cnt_0.c, & at_r + at.c, & \rho_r + \rho.c, & \rho_{i_r} + \rho_i.c, & s^j_r + s^j.c, & id_r + id.c, & b_{0_{blinding}} + b_0.c\\
    \end{matrix}]$$
17. Prover creates responses for $Resp_{state_{new}}$. If balance changes, create response for $bal_1$, otherwise mark as $\bot$. $Resp_{state_{new}}$ =
    $$[\begin{matrix}
    \bot, &  bal_{1_r} + bal_1.c \text{ or } \bot, & \bot, & \bot, & \bot, & \rho_{{i+1}_r} + \rho_{i+1}.c, & s^{2.j}_r + s^{2.j}.c, & \bot, & \bot\\
    \end{matrix}]$$
18. Response for nullifier:
    $$Resp_{null} = \rho_{i_r} + \rho_i.c$$
19. For relation $C_{BP_{\rho,s}}$, only the response for blinding $b'$ needs to be created:
    $Resp_{b'} = r_{BP_{\rho,s}} + b'.c$
    $Resp_{v} = v_{blinding} + v.c$
20. For relation $C_{BP_{bal}}$, only the response for blinding $b''$ and amount $v$ needs to be created:
    $Resp_{b''} = r_{BP_{bal}} + b''.c$
21. Response for asset-id in leg:
    $Resp_{r_4} = r_{4_{blinding}} + r_4.c$
22. Response for public key in leg:
    $Resp_{pk} = r_{pk_{blinding}} + r_{pk}.c$
23. If balance changes, response for amount in leg:
    $Resp_{r_3} = r_{3_{blinding}} + r_3.c$
24. The proof is
    $$
    (C_{BP_{\rho,s}}, C_{BP_{bal}}, State_{old_r}, State_{new}, Path_r, N, T_{State_{old_r}}, T_{State_{new}}, $$
    $$T_{null}, T_{BP_{\rho,s}}, T_{BP_{bal}}, T_{at}, T_{pk}, T_v, Resp_{state_{old_r}}, Resp_{state_{new}}, Resp_{null}, $$
    $$Resp_{b'}, Resp_{b''}, Resp_{v}, Resp_{at}, Resp_{pk}, Resp_{r_3})
    $$


#### Verifier

1. Verifier knows the transaction type $txn\_type$ which determines counter direction and balance change expectations.
2. Verifier hashes the following to create challenge $c$ as:
   $$
   c = Hash(State_{old_r}, State_{new}, N, Path_r, Root, txn\_type, C_{BP_{\rho,s}}, C_{BP_{bal}}, $$
   $$T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{BP_{bal}}, T_{at}, T_{pk}, T_v)
   $$
3. Verifier enforces the Bulletproof constraints for the 2 multiplications: $\rho^{i+1} = \rho.\rho^i$ and $s^{2.j} = s^j.s^j$.
4. Verifier enforces the Bulletproof constraint for the balance change based on $txn\_type$:
    - If $txn\_type \in \{Affirm_s\}$: $bal_1 = bal_0 - v$
    - If $txn\_type \in \{Claim_r, Reverse_s\}$: $bal_1 = bal_0 + v$
5. Verifier enforces the Bulletproof constraints for curve tree membership to verify that $Path_r$ leads to $Root$.
6. Verifies correctness of $State_{old_r}$ by checking:
   $$
   Resp_{state_{old_r}}[0].G_{Aff} + Resp_{state_{old_r}}[1].G_1 + Resp_{state_{old_r}}[2].G_2 + Resp_{state_{old_r}}[3].G_3 + $$
   $$Resp_{state_{old_r}}[4].G_4 + Resp_{state_{old_r}}[5].G_5 + Resp_{state_{old_r}}[6].G_6 + Resp_{state_{old_r}}[7].G_7 + $$
   $$Resp_{state_{old_r}}[8].H_0 \stackrel{?}{=} T_{State_{old_r}} + State_{old_r}.c
   $$
   $$\implies (sk_r + sk.c).G_{Aff} + ( bal_{0_r} + bal_0.c).G_1 + ( cnt_r + cnt_0.c).G_2 + (at_r + at.c).G_3 + $$
   $$(\rho_r + \rho.c).G_4 + (\rho_{i_r} + \rho_i.c).G_5 + (s^j_r + s^j.c).G_6 + $$
   $$(id_r + id.c).G_7 + (b_{0_{blinding}} + b_0.c).H_0 $$
   $$\stackrel{?}{=} T_{State_{old_r}} + State_{old_r}.c$$
7. Verifies correctness of $State_{new}$ by checking:
    - If counter increased by 1:
      $$Resp_{state_{old_r}}[0].G_{Aff} + Resp_{state_{new}}[1].G_1 + Resp_{state_{old_r}}[2].G_2 + Resp_{state_{old_r}}[3].G_3 + $$
      $$Resp_{state_{old_r}}[4].G_4 + Resp_{state_{new}}[5].G_5 + Resp_{state_{new}}[6].G_6 + Resp_{state_{old_r}}[7].G_7 \stackrel{?}{=} T_{State_{new}} + (State_{new} - G_2).c$$
    - If counter decreased by 1:
      $$Resp_{state_{old_r}}[0].G_{Aff} + Resp_{state_{new}}[1].G_1 + Resp_{state_{old_r}}[2].G_2 + Resp_{state_{old_r}}[3].G_3 + $$
      $$Resp_{state_{old_r}}[4].G_4 + Resp_{state_{new}}[5].G_5 + Resp_{state_{new}}[6].G_6 + Resp_{state_{old_r}}[7].G_7 \stackrel{?}{=} T_{State_{new}} + (State_{new} + G_2).c$$

   If balance doesn't change, $Resp_{state_{new}}[1]$ is $\bot$ and verifier uses $Resp_{state_{old_r}}[1]$ for both old and new balance responses.

$$\implies (sk_r + sk.c).G_{Aff} + ( bal_{1_r} + bal_1.c).G_1 + ( cnt_r + cnt_0.c).G_2 + (at_r + at.c).G_3 + $$
$$(\rho_r + \rho.c).G_4 + (\rho_{{i+1}_r} + \rho_{i+1}.c).G_5 + (s^{2.j}_r + s^{2.j}.c).G_6 + $$
$$(id_r + id.c).G_7 \stackrel{?}{=} T_{State_{new}} + (\text{adjusted } State_{new}).c$$

8. Verifies correctness of nullifier by checking:
   $$Resp_{null}.G_5 \stackrel{?}{=} T_{null} + N.c$$
   $$\implies (\rho_{i_r} + \rho_i.c).G_5 \stackrel{?}{=} T_{null} + N.c$$

9. Verifier checks response for $C_{BP_{\rho,s}}$ as:
   $$Resp_{b'}.H_0 + Resp_{state_{old_r}}[4].H_1 + Resp_{state_{old_r}}[5].H_2 + Resp_{state_{new}}[5].H_3 + Resp_{state_{old_r}}[6].H_4 + $$
   $$Resp_{state_{new}}[6].H_5 \stackrel{?}{=} T_{BP_{\rho,s}} + C_{BP_{\rho,s}}.c$$
   $$\implies (r_{BP_{\rho,s}} + b'.c).H_0 + (\rho_r + \rho.c).H_1 + (\rho_{i_r} + \rho_i.c).H_2 + (\rho_{{i+1}_r} + \rho_{i+1}.c).H_3 + (s^j_r + s^j.c).H_4 + $$
   $$(s^{2.j}_r + s^{2.j}.c).H_5 \stackrel{?}{=} T_{BP_{\rho,s}} + C_{BP_{\rho,s}}.c$$

10. Verifier checks response for $C_{BP_{bal}}$ as:
    $$Resp_{b''}.H_0 + Resp_v.H_1 + Resp_{state_{old_r}}[1].H_2 + Resp_{state_{new}}[1].H_3 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$$
    $$\implies (r_{BP_{bal}} + b''.c).H_0 + (v_{blinding} + v.c).H_1 + ( bal_{0_r} + bal_0.c).H_2 + ( bal_{1_r} + bal_1.c).H_3 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$$

11. Verifier checks response for $CT_{at}$ by checking:
    $$Resp_{r_4}.G_{Enc} + Resp_{state_{old_r}}[3].H \stackrel{?}{=} T_{at} + CT_{at}.c$$
    $$\implies (r_{4_{blinding}} + r_4.c).G_{Enc} + (at_r + at.c).H \stackrel{?}{=} T_{at} + CT_{at}.c$$

12. Verifier checks response for public key in leg by checking:
    $$Resp_{pk}.G_{Enc} + Resp_{state_{old_r}}[0].G_{Aff} \stackrel{?}{=} T_{pk} + CT_s.c \text{ (if sender)}$$
    $$\implies (r_{pk_{blinding}} + r_{pk}.c).G_{Enc} + (sk_r + sk.c).G_{Aff} \stackrel{?}{=} T_{pk} + CT_s.c$$

    $Resp_{pk}.G_{Enc} + Resp_{state_{old_r}}[0].G_{Aff} \stackrel{?}{=} T_{pk} + CT_r.c \text{ (if receiver)}$
    $\implies (r_{pk_{blinding}} + r_{pk}.c).G_{Enc} + (sk_r + sk.c).G_{Aff} \stackrel{?}{=} T_{pk} + CT_s.c$

13. If balance changes, verifier checks response for amount in leg by checking:
    $$Resp_{r_3}.G_{Enc} + Resp_{v}.H \stackrel{?}{=} T_v + CT_v.c$$
    $$\implies (r_{3_{blinding}} + r_3.c).G_{Enc} + (v_{blinding} + v.c).H \stackrel{?}{=} T_v + CT_v.c$$

14. Verifier finally checks the Bulletproofs proof for all constraints i.e. curve tree membership, multiplications, and balance change