# Sender/Receiver Affirmations

## Affirmations
Once has settlement has been posted on chain, sender/receiver send their agreement along with a proof which proves that they are the party to that leg, and they have done a correct account state transition, invalidating previous state by submitting the nullifier and their revealing their new state. Note that they don't point to their old state in the accumulator.

For an account state to transition from $State_{old}$ to $State_{new}$,
- secret key $sk$, identity $id$ and asset-id $at$ should not change
- nullifier should be revealed as $\rho^i.G_5$
- nullifier secret key $\rho^i$ and randomness $s^j$ should change as: $\rho^{i+1} = \rho.\rho^i$, $s^{2.j} = s^j.s^j$

Old state
$$
State_{old} = sk.G_{Aff} + balance.G_1 + counter.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7 \quad State_{old} \in \mathbb{G}_p
$$

New state
$$
State_{new} = sk.G_{Aff} + balance'.G_1 + counter'.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7 \quad State_{new} \in \mathbb{G}_p
$$

$balance$ might or might not be same as $balance'$ depending on who is affirming or what kind of transaction it is. $counter'$ might be same or 1 more or 1 less than $counter$ depending on the kind of transaction.
Also, it must be proved that the $State_{old}$ has same asset-id $at$ that is in the leg and has the public key for the same secret key as in the account.


For a single leg settlement of amount $v$:

1. When a sender affirms a leg, its new account state's balance should be $v$ less than the old account's and its counter should increase by 1.
2. When a receiver affirms a leg, its new account state's balance should be same as the old account's and its counter should increase by 1.
3. Sender can revert its affirmation by creating a new account state which has the balance increased by $v$ and counter decreased by 1.
4. Receiver can revert its affirmation by creating a new account state with counter decreased by 1.
5. Once a settlement has been confirmed, i.e. it cant be reverted,
    - sender can send a counter update txn to decrease it's counter by 1
    - receiver can send a claim funds txn to increases it's balance by $v$ and decrease it's counter by 1.

However, sender and receiver do have an option to send an irreversible affirmation and in that case, they don't change their counter, unless the settlement expires in which case the party who had sent, reverses it. 

Table describing changes to balance and counter for various transactions. Subscripts $_s$ and $_r$ refer to txn sent by sender and receiver respectively.

| Transaction Type     | Description                                        | Balance Change | Counter Change |
|----------------------|----------------------------------------------------|----------------|----------------|
| **$Affirm_s$**       | Sender affirms a leg of amount $v$                 | **-v**         | **+1**         |
| **$Affirm_r$**       | Receiver affirms a leg                             | **0**          | **+1**         |
| **$Claim_r$**        | Receiver claims funds after settlement             | **+v**         | **-1**         |
| **$CntUpd_s$**       | Sender updates counter after settlement            | **0**          | **-1**         |
| **$Reverse_s$**      | Sender reverses their affirmation                  | **+v**         | **-1**         |
| **$Reverse_r$**      | Receiver reverses their affirmation                | **0**          | **-1**         |
| **$Irr$-$Affirm_s$** | Sender irreversibly affirms a leg of amount $v$    | **-v**         | **0**          |
| **$Irr$-$Affirm_r$** | Receiver irreversibly affirms a leg of amount $v$  | **+v**         | **0**          |

### Protocol
This section describes a unified account state transition proof which can handle all the above scenarios and parts of this proof can be omitted when balance doesn't change
Here the prover (sender/receiver) wants to prove following relations when sending affirmation for leg with amount $v$:

1. $State_{old} = sk.G_{Aff} + bal_0.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7$
2. Similarly, $State_{new} = sk.G_{Aff} + bal_1.G_1 + cnt_1.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$
3. $State_{old}$ exists in the accumulator (account curve tree)
4. $N = \rho^i.G_5$
5. $\rho^{i+1} = \rho.\rho^i$
6. $s^{2.j} = s^j.s^j$
7. If balance change is expected,
    - $bal_1 = bal_0 - v$ (for **Affirm_s**, **$Irr$-$Affirm_s$**)
    - $bal_1 = bal_0 + v$ (for **Claim_r**, **Reverse_s**, **$Irr$-$Affirm_r$**)
8. Counter change:
    - $cnt_1 = cnt_0 + 1$ (**Affirm_s**, **Affirm_r**)
    - $cnt_1 = cnt_0 - 1$ (**Claim_r**, **CntUpd_s**, **Reverse_s**, **Reverse_r**)
    - $cnt_1 = cnt_0$ (**$Irr$-$Affirm_s$**, **$Irr$-$Affirm_r$**)
9. Since the change to counter is public, relation for $State_{new}$ can be expressed as:
    - $State_{new} - G_2 = sk.G_{Aff} + bal_1.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$ if counter increased by 1.
    - $State_{new} + G_2 = sk.G_{Aff} + bal_1.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$ if counter decreased by 1.
    - $State_{new} = sk.G_{Aff} + bal_1.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$ if counter remains same.
10. $bal_1 <= MAX\_BALANCE$ to avoid overflows
11. Prove that asset id in $CT_{at}$ is $at$
12. If transition involves a balance change, prove that amount in $CT_v$ is $v$
13. Prove that $sk$ is the secret key of public key in:
    - $CT_s$ if they are sender
    - $CT_r$ if they are receiver

**Instance**: $State_{old_r}$, $State_{new}$, $N$, $Path_r$, $Root$, $CT_s$, $CT_r$, $CT_v$, $CT_{at}$, $G_{Aff}$, $G_i$, $H$, $H_i$, $\widetilde{G}$, $\widetilde{G}_i$, $\widetilde{H}$, $\widetilde{H}_i$

**Witness**: $sk, at, id, v, bal_0, bal_1, cnt, \rho, \rho^i, \rho^{i+1}, s^j, s^{2.j}, Path$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

#### Prover
1. Prover first wants to prove knowledge of $sk, at, bal_0, cnt, \rho, \rho^i, s^j, id$ in the relation $$State_{old} = sk.G_{Aff} + bal_0.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7$$
2. Similarly, prover wants to prove knowledge of $sk, at, bal_1, cnt, \rho, \rho^{i+1}, s^{2.j}, id$ in $State_{new}$ from relation 10.
    - If counter increased by 1: $$State_{new} - G_2 = sk.G_{Aff} + bal_1.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$$
    - If counter decreased by 1: $$State_{new} + G_2 = sk.G_{Aff} + bal_1.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$$
    - If counter remains same: $$State_{new} = sk.G_{Aff} + bal_1.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$$
3. Prover gets the path of the leaf $State_{old}$ as $Path$, an array of nodes (curve points), and randomizes it by adding blindings to all nodes. This will result in the leaf $State_{old}$ being transformed into $State_{old_r} = State_{old} + b_0.H_0$ and $Path$ transforms into $Path_r$. Prover enforces the constraints for curve tree membership using $Path, Path_r, b_i$.
4. Since prover knows the opening of $State_{old}$ and $b_0$, it can prove the knowledge of opening of $State_{old_r}$ as well. So relation 1 can be transformed as:
   $$
   sk.G_{Aff} + bal_0.G_1 + cnt_0.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7 + b_0.H_0 = State_{old_r}
   $$
5. Prover picks random $$sk_r, at_r,  bal_{0_r},  cnt_r, \rho_r, \rho^i_r, \rho^{i+1}_r, s^j_r, s^{2.j}_r, id_r, b_{0_r} \in \mathbb{Z}_p$$ and creates:
   $$T_{State_{old_r}} = sk_r.G_{Aff} +  bal_{0_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + $$
   $$\rho^i_r.G_5 + s^j_r.G_6 + id_r.G_7 + b_{0_r}.H_0, \in \mathbb{G}_p$$
6. For the new state, create:
   $$T_{State_{new}} = sk_r.G_{Aff} +  bal_{1_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + $$
   $$\rho^{i+1}_r.G_5 + s^{2.j}_r.G_6 + id_r.G_7, \in \mathbb{G}_p$$

   Same blindings for $sk, at, cnt, \rho, id$ are used in both old and new state since these values don't change. If balance doesn't change, also use same blinding so $bal_{0_r} = bal_{1_r}$.
7. For the correctness of nullifier, prover creates:
   $$
   T_{null} = \rho^i_r.G_5, \in \mathbb{G}_p
   $$
8. For enforcing $\rho^{i+1} = \rho.\rho^i$ and $s^{2.j} = s^j.s^j$, prover sets up the constraints in Bulletproof as both are multiplications. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of committed values in Bulletproof's commitment and in the state commitments. Let $C_{BP_{\rho,s}}$ be the commitment:
   $$
   C_{BP_{\rho,s}} = b'.H_0 + \rho.H_1 + \rho^i.H_2 + \rho^{i+1}.H_3 + s^j.H_4 + s^{2.j}.H_5, \in \mathbb{G}_p
   $$
9. If the balance changes, prover sets up constraint in Bulletproof based on transaction type:
    - If balance change is $-v$: $bal_1 = bal_0 - v$
    - If balance change is $+v$: $bal_1 = bal_0 + v$

   Let $C_{BP_{bal}}$ be the commitment:
   $$
   C_{BP_{bal}} = b''.H_0 + v.H_1 + bal_0.H_2 + bal_1.H_3, \in \mathbb{G}_p
   $$
10. Prover creates commitment for $C_{BP_{\rho,s}}$ by picking random $r_{BP_{\rho,s}} \in \mathbb{Z}_p$:
    $$
    T_{BP_{\rho,s}} = r_{BP_{\rho,s}}.H_0 + \rho_r.H_1 + \rho^i_r.H_2 + \rho^{i+1}_r.H_3 + s^j_r.H_4 + s^{2.j}_r.H_5, \in \mathbb{G}_p
    $$
11. Prover creates commitment for $C_{BP_{bal}}$ by picking random $v_r, r_{BP_{bal}} \in \mathbb{Z}_p$:
    $$
    T_{BP_{bal}} = r_{BP_{bal}}.H_0 + v_r.H_1 +  bal_{0_r}.H_2 +  bal_{1_r}.H_3, \in \mathbb{G}_p
    $$
12. For proving $at$ in $CT_{at}$, picks random $r_{4_r} \in \mathbb{Z}_p$ and creates:
    $T_{at} = r_{4_r}.G_{Enc} + at_r.H$
13. For proving the correctness of public key in leg, picks random $r_{pk_r} \in \mathbb{Z}_p$ and creates:
    $$T_{pk} = r_{pk_r}.G_{Enc} + sk_r.G_{Aff}$$
14. If balance changes, picks random $r_{3_r} \in \mathbb{Z}_p$ and creates:
    $T_v = r_{3_r}.G_{Enc} + v_r.H$
15. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_{old_r}, State_{new}, N, Path_r, Root, txn\_type, CT_s, CT_r, CT_v, CT_{at}, C_{BP_{\rho,s}}, C_{BP_{bal}}, $$
    $$T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{BP_{bal}}, T_{at}, T_{pk}, T_v)$$
16. Prover creates responses for $resp_{state_{old_r}}$ =
    $$[\begin{matrix}
    sk_r + sk.c, &  bal_{0_r} + bal_0.c, &  cnt_r + cnt_0.c, & at_r + at.c, & \rho_r + \rho.c, & \rho^i_r + \rho^i.c, & s^j_r + s^j.c, & id_r + id.c, & b_{0_r} + b_0.c\\
    \end{matrix}]$$
17. Prover creates responses for $resp_{state_{new}}$. If balance changes, create response for $bal_1$, otherwise mark as $\bot$. $resp_{state_{new}}$ =
    $$[\begin{matrix}
    \bot, &  bal_{1_r} + bal_1.c \text{ or } \bot, & \bot, & \bot, & \bot, & \rho^{i+1}_r + \rho^{i+1}.c, & s^{2.j}_r + s^{2.j}.c, & \bot, & \bot\\
    \end{matrix}]$$
18. Response for nullifier:
    $$resp_{null} = \rho^i_r + \rho^i.c$$
19. For relation $C_{BP_{\rho,s}}$, only the response for blinding $b'$ needs to be created:
    $resp_{b'} = r_{BP_{\rho,s}} + b'.c$
20. For relation $C_{BP_{bal}}$, only the response for blinding $b''$ and amount $v$ needs to be created:
    $resp_{b''} = r_{BP_{bal}} + b''.c$
    $resp_{v} = v_r + v.c$
21. Response for asset-id in leg:
    $resp_{r_4} = r_{4_r} + r_4.c$
22. Response for public key ($r_1$ or $r_2$ depending on sender or receiver) in leg:
    $resp_{pk} = r_{pk_r} + r_{pk}.c$
23. If balance changes, response for amount in leg:
    $resp_{r_3} = r_{3_r} + r_3.c$
24. The proof is
    $$
    (C_{BP_{\rho,s}}, C_{BP_{bal}}, State_{old_r}, State_{new}, Path_r, N, T_{State_{old_r}}, T_{State_{new}}, $$
    $$T_{null}, T_{BP_{\rho,s}}, T_{BP_{bal}}, T_{at}, T_{pk}, T_v, resp_{state_{old_r}}, resp_{state_{new}}, resp_{null}, $$
    $$resp_{b'}, resp_{b''}, resp_{v}, resp_{r_4}, resp_{pk}, resp_{r_3})
    $$


#### Verifier

1. Verifier knows the transaction type $txn\_type$ which determines counter direction and balance change expectations.
2. Verifier hashes the following to create challenge $c$ as:
   $$
   c = Hash(State_{old_r}, State_{new}, N, Path_r, Root, txn\_type, C_{BP_{\rho,s}}, C_{BP_{bal}}, $$
   $$T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{BP_{bal}}, T_{at}, T_{pk}, T_v)
   $$
3. Verifier enforces the Bulletproof constraints for the 2 multiplications: $\rho^{i+1} = \rho.\rho^i$ and $s^{2.j} = s^j.s^j$.
4. Verifier enforces the Bulletproof constraint for the balance change based on $txn\_type$:
    - If $txn\_type \in \{Affirm_s, Irr-Affirm_s\}$: $bal_1 = bal_0 - v$
    - If $txn\_type \in \{Claim_r, Reverse_s, Irr-Affirm_r\}$: $bal_1 = bal_0 + v$
5. Verifier enforces the Bulletproof constraints for curve tree membership to verify that $Path_r$ leads to $Root$.
6. Verifies correctness of $State_{old_r}$ by checking:
   $$
   resp_{state_{old_r}}[0].G_{Aff} + resp_{state_{old_r}}[1].G_1 + resp_{state_{old_r}}[2].G_2 + resp_{state_{old_r}}[3].G_3 + $$
   $$resp_{state_{old_r}}[4].G_4 + resp_{state_{old_r}}[5].G_5 + resp_{state_{old_r}}[6].G_6 + resp_{state_{old_r}}[7].G_7 + $$
   $$resp_{state_{old_r}}[8].H_0 \stackrel{?}{=} T_{State_{old_r}} + State_{old_r}.c
   $$
   $$\implies (sk_r + sk.c).G_{Aff} + ( bal_{0_r} + bal_0.c).G_1 + ( cnt_r + cnt_0.c).G_2 + (at_r + at.c).G_3 + $$
   $$(\rho_r + \rho.c).G_4 + (\rho^i_r + \rho^i.c).G_5 + (s^j_r + s^j.c).G_6 + $$
   $$(id_r + id.c).G_7 + (b_{0_r} + b_0.c).H_0 $$
   $$\stackrel{?}{=} sk_r.G_{Aff} +  bal_{0_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + \rho^i_r.G_5 + s^j_r.G_6 + id_r.G_7 + b_{0_r}.H_0 + State_{old_r}.c$$
7. Verifies correctness of $State_{new}$ by checking:
    - If counter increased by 1:
      $$resp_{state_{old_r}}[0].G_{Aff} + resp_{state_{new}}[1].G_1 + resp_{state_{old_r}}[2].G_2 + resp_{state_{old_r}}[3].G_3 + $$
      $$resp_{state_{old_r}}[4].G_4 + resp_{state_{new}}[5].G_5 + resp_{state_{new}}[6].G_6 + resp_{state_{old_r}}[7].G_7 \stackrel{?}{=} T_{State_{new}} + (State_{new} - G_2).c$$
      $$\implies (sk_r + sk.c).G_{Aff} + (bal_{1_r} + bal_1.c).G_1 + (cnt_r + cnt_0.c).G_2 + (at_r + at.c).G_3 + $$
      $$(\rho_r + \rho.c).G_4 + (\rho^{i+1}_r + \rho^{i+1}.c).G_5 + (s^{2.j}_r + s^{2.j}.c).G_6 + $$
      $$(id_r + id.c).G_7 \stackrel{?}{=} sk_r.G_{Aff} +  bal_{1_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + \rho^{i+1}_r.G_5 + s^{2.j}_r.G_6 + id_r.G_7 + (State_{new} - G_2).c$$
    - If counter decreased by 1:
      $$resp_{state_{old_r}}[0].G_{Aff} + resp_{state_{new}}[1].G_1 + resp_{state_{old_r}}[2].G_2 + resp_{state_{old_r}}[3].G_3 + $$
      $$resp_{state_{old_r}}[4].G_4 + resp_{state_{new}}[5].G_5 + resp_{state_{new}}[6].G_6 + resp_{state_{old_r}}[7].G_7 \stackrel{?}{=} T_{State_{new}} + (State_{new} + G_2).c$$
      $$\implies (sk_r + sk.c).G_{Aff} + (bal_{1_r} + bal_1.c).G_1 + (cnt_r + cnt_0.c).G_2 + (at_r + at.c).G_3 + $$
      $$(\rho_r + \rho.c).G_4 + (\rho^{i+1}_r + \rho^{i+1}.c).G_5 + (s^{2.j}_r + s^{2.j}.c).G_6 + $$
      $$(id_r + id.c).G_7 \stackrel{?}{=} sk_r.G_{Aff} +  bal_{1_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + \rho^{i+1}_r.G_5 + s^{2.j}_r.G_6 + id_r.G_7 + (State_{new} + G_2).c$$
    - If counter remains same:
      $$resp_{state_{old_r}}[0].G_{Aff} + resp_{state_{new}}[1].G_1 + resp_{state_{old_r}}[2].G_2 + resp_{state_{old_r}}[3].G_3 + $$
      $$resp_{state_{old_r}}[4].G_4 + resp_{state_{new}}[5].G_5 + resp_{state_{new}}[6].G_6 + resp_{state_{old_r}}[7].G_7 \stackrel{?}{=} T_{State_{new}} + State_{new}.c$$
      $$\implies (sk_r + sk.c).G_{Aff} + (bal_{1_r} + bal_1.c).G_1 + (cnt_r + cnt_0.c).G_2 + (at_r + at.c).G_3 + $$
      $$(\rho_r + \rho.c).G_4 + (\rho^{i+1}_r + \rho^{i+1}.c).G_5 + (s^{2.j}_r + s^{2.j}.c).G_6 + $$
      $$(id_r + id.c).G_7 \stackrel{?}{=} sk_r.G_{Aff} +  bal_{1_r}.G_1 +  cnt_r.G_2 + at_r.G_3 + \rho_r.G_4 + \rho^{i+1}_r.G_5 + s^{2.j}_r.G_6 + id_r.G_7 + State_{new}.c$$
   
   If balance doesn't change, $resp_{state_{new}}[1]$ is $\bot$ and verifier uses $resp_{state_{old_r}}[1]$ for both old and new balance responses.

8. Verifies correctness of nullifier by checking:
   $$resp_{null}.G_5 \stackrel{?}{=} T_{null} + N.c$$
   $$\implies (\rho^i_r + \rho^i.c).G_5 \stackrel{?}{=} \rho^i_r.G_5 + N.c$$

9. Verifier checks response for $C_{BP_{\rho,s}}$ as:
   $$resp_{b'}.H_0 + resp_{state_{old_r}}[4].H_1 + resp_{state_{old_r}}[5].H_2 + resp_{state_{new}}[5].H_3 + resp_{state_{old_r}}[6].H_4 + $$
   $$resp_{state_{new}}[6].H_5 \stackrel{?}{=} T_{BP_{\rho,s}} + C_{BP_{\rho,s}}.c$$
   $$\implies (r_{BP_{\rho,s}} + b'.c).H_0 + (\rho_r + \rho.c).H_1 + (\rho^i_r + \rho^i.c).H_2 + (\rho^{i+1}_r + \rho^{i+1}.c).H_3 + (s^j_r + s^j.c).H_4 + $$
   $$(s^{2.j}_r + s^{2.j}.c).H_5 \stackrel{?}{=} r_{BP_{\rho,s}}.H_0 + \rho_r.H_1 + \rho^i_r.H_2 + \rho^{i+1}_r.H_3 + s^j_r.H_4 + s^{2.j}_r.H_5 + C_{BP_{\rho,s}}.c$$

10. Verifier checks response for $C_{BP_{bal}}$ as:
    $$resp_{b''}.H_0 + resp_v.H_1 + resp_{state_{old_r}}[1].H_2 + resp_{state_{new}}[1].H_3 \stackrel{?}{=} T_{BP_{bal}} + C_{BP_{bal}}.c$$
    $$\implies (r_{BP_{bal}} + b''.c).H_0 + (v_r + v.c).H_1 + ( bal_{0_r} + bal_0.c).H_2 + ( bal_{1_r} + bal_1.c).H_3 \stackrel{?}{=} r_{BP_{bal}}.H_0 + $$
    $$v_r.H_1 +  bal_{0_r}.H_2 +  bal_{1_r}.H_3 + C_{BP_{bal}}.c$$

11. Verifier checks response for $CT_{at}$ by checking:
    $$resp_{r_4}.G_{Enc} + resp_{state_{old_r}}[3].H \stackrel{?}{=} T_{at} + CT_{at}.c$$
    $$\implies (r_{4_r} + r_4.c).G_{Enc} + (at_r + at.c).H \stackrel{?}{=} r_{4_r}.G_{Enc} + at_r.H + CT_{at}.c$$

12. Verifier checks response for public key in leg by checking:
    $$resp_{pk}.G_{Enc} + resp_{state_{old_r}}[0].G_{Aff} \stackrel{?}{=} T_{pk} + CT_s.c \text{ (if sender)}$$
    $$\implies (r_{pk_r} + r_{pk}.c).G_{Enc} + (sk_r + sk.c).G_{Aff} \stackrel{?}{=} r_{pk_r}.G_{Enc} + sk_r.G_{Aff} + CT_s.c$$

    $resp_{pk}.G_{Enc} + resp_{state_{old_r}}[0].G_{Aff} \stackrel{?}{=} T_{pk} + CT_r.c \text{ (if receiver)}$
    $\implies (r_{pk_r} + r_{pk}.c).G_{Enc} + (sk_r + sk.c).G_{Aff} \stackrel{?}{=} r_{pk_r}.G_{Enc} + sk_r.G_{Aff} + CT_r.c$

13. If balance changes, verifier checks response for amount in leg by checking:
    $$resp_{r_3}.G_{Enc} + resp_{v}.H \stackrel{?}{=} T_v + CT_v.c$$
    $$\implies (r_{3_r} + r_3.c).G_{Enc} + (v_r + v.c).H \stackrel{?}{=} r_{3_r}.G_{Enc} + v_r.H + CT_v.c$$

14. Verifier finally checks the Bulletproofs proof for all constraints i.e. curve tree membership, multiplications, and balance change

## Proof of balance

An investor can be asked for proof of balance of certain account (of certain asset-id). 
The requester of this proof might be the auditor who has visibility of the pending settlements, or it 
might be someone else who the investor should prove that the sum of its finalized balance and balance 
in pending settlements is certain value. The prover's public key, asset-id and balance are revealed to the verifier. 
The investor also reveals the nullifier of the account to prove that it is using the latest account state as the verifier 
can check that nullifier has not been revealed. An improvement could be to prove knowledge of an unrevealed nullifier using a 
proof of non-membership in the nullifier set (nullifier set has to be an accumulator). 
The prover should share the index of account commitment in tree so verifier can efficiently fetch the commitment and compare. 
If its not possible then do a membership proof. Prover could hide the commitment by randomizing it with a new blinding ($State' = State + B.r'$)

There are 2 variants of this proof:

1. **Proof of balance with auditor**: The verifier is an auditor who already has visibility of the account state including the counter. The prover only needs to prove correctness of the public key and nullifier against the account commitment.
2. **Proof of balance with non-auditor**: The verifier is an arbitrary party who may not have visibility of pending transactions. The prover must prove the counter equals the number of legs provided, prove their role in each leg, and prove the sum of pending amounts.

### Proof of balance with auditor

In this protocol, the verifier is an auditor who already has access to the account commitment and knows the counter value. The prover must prove:

1. The secret key $sk$ in the account commitment corresponds to the revealed public key $PK_{Aff}$
2. The nullifier $N$ is correctly derived from $\rho^i$ in the account commitment

**Instance**: $State, PK_{Aff}, at, balance, counter, id, N, G_{Aff}$

**Witness**: $sk, \rho, \rho^i, s^j$

#### Prover

1. Prover wants to prove knowledge of $\rho, \rho^i, s$ in the relation:
   $$\rho.G_4 + \rho^i.G_5 + s^j.G_6 = State - PK_{Aff} - balance.G_1 - counter.G_2 - at.G_3 - id.G_7$$
   where the RHS is public.
2. Prover wants to prove knowledge of $\rho^i$ in $N = \rho^i.G_5$.
3. Prover wants to prove knowledge of $sk$ in $PK_{Aff} = sk.G_{Aff}$.
4. Prover picks random $\rho_r, \rho^i_r, s^j_r, sk_r \in \mathbb{Z}_p$ and creates:
   $$T_{acc} = \rho_r.G_4 + \rho^i_r.G_5 + s^j_r.G_6, \in \mathbb{G}_p$$
   $$T_{null} = \rho^i_r.G_5, \in \mathbb{G}_p$$
   $$T_{pk} = sk_r.G_{Aff}, \in \mathbb{G}_p$$
5. Prover hashes the following to create challenge $c$ as:
   $$c = Hash(State, PK_{Aff}, at, balance, counter, id, N, T_{acc}, T_{null}, T_{pk})$$
6. Prover creates responses:
   $$resp_{acc} = [\begin{matrix}
   \rho_r + \rho.c, & \rho^i_r + \rho^i.c, & s^j_r + s.c\\
   \end{matrix}]$$
   $$resp_{pk} = sk_r + sk.c$$
7. The proof is
   $$(N, T_{acc}, T_{null}, T_{pk}, resp_{acc}, resp_{pk})$$

#### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$c = Hash(State, PK_{Aff}, at, balance, counter, id, N, T_{acc}, T_{null}, T_{pk})$$
2. Verifies correctness of account state by checking:
   $$resp_{acc}[0].G_4 + resp_{acc}[1].G_5 + resp_{acc}[2].G_6 \stackrel{?}{=} T_{acc} + (State - PK_{Aff} - balance.G_1 - counter.G_2 - at.G_3 - id.G_7).c$$
   $$\implies (\rho_r + \rho.c).G_4 + (\rho^i_r + \rho^i.c).G_5 + (s^j_r + s^j.c).G_6 \stackrel{?}{=} \rho_r.G_4 + \rho^i_r.G_5 + $$
   $$s^j_r.G_6 + (State - PK_{Aff} - balance.G_1 - counter.G_2 - at.G_3 - id.G_7).c$$
3. Verifies correctness of nullifier by checking:
   $$resp_{acc}[1].G_5 \stackrel{?}{=} T_{null} + N.c$$
   $$\implies (\rho^i_r + \rho^i.c).G_5 \stackrel{?}{=} \rho^i_r.G_5 + N.c$$
4. Verifies knowledge of secret key by checking:
   $$resp_{pk}.G_{Aff} \stackrel{?}{=} T_{pk} + PK_{Aff}.c$$
   $$\implies (sk_r + sk.c).G_{Aff} \stackrel{?}{=} sk_r.G_{Aff} + PK_{Aff}.c$$

### Proof of balance with non-auditor

In this protocol, the verifier is an arbitrary party who may not have visibility of the pending transactions. The prover provides all pending leg encryptions and must additionally prove:

1. The counter equals the number of legs provided
2. The prover has the correct role (sender or receiver) in each leg, i.e.
    - in each leg index $k$ where prover is sender, $CT_{s_k} - PK_{Aff} = r_{1_k}.G_{Enc}$
    - in each leg index $k$ where prover is receiver, $CT_{r_k} - PK_{Aff} = r_{2_k}.G_{Enc}$
3. The asset-id in each leg matches the account's asset-id, i.e. in each leg index $k$, $CT_{at_k} - at.H = r_{4_k}.G_{Enc}$
4. The sum of amounts in legs where prover is sender equals the declared pending sent amount
5. The sum of amounts in legs where prover is receiver equals the declared pending received amount

For relations 2 and 3 above, we again use the batch Schnorr protocol from Fig. 2 of [this paper](https://iacr.org/archive/asiacrypt2004/33290273/33290273.pdf) like we used for 
key registration proofs. This makes the proof size independent of the number of legs.

For relations 4, 5, we use the fact the Elgamal encryption is additively homomorphic so $\sum_i CT_{v_i} = (\sum_i r_{3_i}).G_{enc} + (\sum_i v_i).H$ which is
a Pedersen commitment to the sum of amounts in each $CT_{v_i}$

Let $S$ and $R$ be the leg indices where prover is sender and receiver respectively.

**Instance**: $State, PK_{Aff}, at, balance, counter, id, N, Leg_k, pending\_sent, pending\_recv, G_{Aff}, G_{Enc}, H$

**Witness**: $sk, \rho, \rho^i, s^j, (r_1, r_2, r_3, r_4)_k$

Here $Leg_k$ denotes the set of leg encryptions $(CT_s, CT_r, CT_v, CT_{at})$ for each leg, and $(r_1, r_2, r_3, r_4)_k$ are the encryption randomness for that leg.

#### Prover

1. Prover wants to prove the same account state relation as in proof with auditor:
   $$\rho.G_4 + \rho^i.G_5 + s^j.G_6 = State - PK_{Aff} - balance.G_1 - counter.G_2 - at.G_3 - id.G_7$$
2. Prover wants to prove knowledge of $\rho^i$ in $N = \rho^i.G_5$ and $sk$ in $PK_{Aff} = sk.G_{Aff}$.
3. For each leg $k$ where prover is sender, prove knowledge of $r_{1_k}$ in:
   $$CT_{s_k} - PK_{Aff} = r_{1_k}.G_{Enc}$$
4. For each leg $k$ where prover is receiver, prove knowledge of $r_{2_k}$ in:
   $$CT_{r_k} - PK_{Aff} = r_{2_k}.G_{Enc}$$
5. For each leg $k$, prove knowledge of $r_{4_k}$ in:
   $$CT_{at_k} - at.H = r_{4_k}.G_{Enc}$$
6. Let $S$ be the set of leg indices where prover is sender. Prove knowledge of $\sum_{k \in S} r_{3_k}$ in:
   $$\sum_{k \in S} CT_{v_k} - pending\_sent.H = (\sum_{k \in S} r_{3_k}).G_{Enc}$$
7. Let $R$ be the set of leg indices where prover is receiver. Prove knowledge of $\sum_{k \in R} r_{3_k}$ in:
   $$\sum_{k \in R} CT_{v_k} - pending\_recv.H = (\sum_{k \in R} r_{3_k}).G_{Enc}$$
8. Prover picks random $\rho_r, \rho^i_r, s^j_r, sk_r, r_{1_r}, r_{2_r}, r_{4_r}, r_{sent_v}, r_{recv_v} \in \mathbb{Z}_p$ and creates:
   $$T_{acc} = \rho_r.G_4 + \rho^i_r.G_5 + s^j_r.G_6$$
   $$T_{null} = \rho^i_r.G_5$$
   $$T_{pk} = sk_r.G_{Aff}$$
   $$T_{r_4} = r_{4_r}.G_{Enc}$$
   $$T_{pk\_send} = r_{1_r}.G_{Enc}$$ if prover is sender in any leg
   $$T_{pk\_recv} = r_{2_r}.G_{Enc}$$ if prover is receiver in any leg
   $$T_{sent_v} = r_{sent_v}.G_{Enc}$$ if prover is sender in any leg
   $$T_{recv_v} = r_{recv_v}.G_{Enc}$$ if prover is receiver in any leg
9. Prover hashes the following to create challenge $c$ as:
   $$c = Hash(State, PK_{Aff}, at, balance, counter, id, N, Leg_k, pending\_sent, pending\_recv, $$
   $$T_{acc}, T_{null}, T_{pk}, T_{r_4}, T_{pk\_send}, T_{pk\_recv}, T_{sent_v}, T_{recv_v})$$
10. Prover creates responses for $sk, \rho, \rho^i, s^j, \sum_{k \in S} r_{3_k}, \sum_{k \in R} r_{3_k}$ as:
    $$resp_{acc} = [\begin{matrix}
    \rho_r + \rho.c, & \rho^i_r + \rho^i.c, & s^j_r + s.c\\
    \end{matrix}]$$
    $$resp_{pk} = sk_r + sk.c$$
    $$resp_{sent_v} = r_{sent_v} + (\sum_{k \in S} r_{3_k}).c$$
    $$resp_{recv_v} = r_{recv_v} + (\sum_{k \in R} r_{3_k}).c$$
11. For each $r_1, r_2, r_3$, prover creates an aggregated response as per the batch Schnorr protocol
    
    For each $Leg_k$
    $$resp_{r_4} = r_{4_r} + \sum_{k} r_{4_k}.c^k$$

    For each $Leg_k$ where $k \in S$
    $$resp_{pk\_send} = r_{1_r} + \sum_{k} r_{1_k}.c^k$$ 

    For each $Leg_k$ where $k \in R$
    $$resp_{pk\_recv} = r_{2_r} + \sum_{k} r_{2_k}.c^k$$

12. The proof is
    $$(N, T_{acc}, T_{null}, T_{pk}, T_{r_4}, T_{pk\_send}, T_{pk\_recv}, T_{sent_v}, T_{recv_v}, $$
    $$resp_{acc}, resp_{pk}, resp_{r_4}, resp_{pk\_send}, resp_{pk\_recv}, resp_{sent_v}, resp_{recv_v})$$

#### Verifier

1. Verifier reconstructs the challenge $c$ as
   $$c = (State, PK_{Aff}, at, balance, counter, id, N, Leg_k, pending\_sent, pending\_recv, $$
   $$T_{acc}, T_{null}, T_{pk}, T_{r_4}, T_{pk\_send}, T_{pk\_recv}, T_{sent_v}, T_{recv_v})$$
2. Verifier checks that counter equals number of legs provided and responses for sender/receiver public key and amounts are provided accordingly.
3. Verifies correctness of account state by checking:
   $$resp_{acc}[0].G_4 + resp_{acc}[1].G_5 + resp_{acc}[2].G_6 \stackrel{?}{=} T_{acc} + (State - PK_{Aff} - balance.G_1 - counter.G_2 - at.G_3 - id.G_7).c$$
   $$\implies (\rho_r + \rho.c).G_4 + (\rho^i_r + \rho^i.c).G_5 + (s^j_r + s.c).G_6 \stackrel{?}{=} \rho_r.G_4 + \rho^i_r.G_5 + $$
   $$s^j_r.G_6 + (State - PK_{Aff} - balance.G_1 - counter.G_2 - at.G_3 - id.G_7).c$$
4. Verifies correctness of nullifier by checking:
   $$resp_{acc}[1].G_5 \stackrel{?}{=} T_{null} + N.c$$
   $$\implies (\rho^i_r + \rho^i.c).G_5 \stackrel{?}{=} \rho^i_r.G_5 + N.c$$
   
   Note that verifier uses $resp_{acc}[1]$ for checking both the account commitment and nullifier, proving that the same $\rho^i$ is used in both relations.
5. Verifies knowledge of secret key by checking:
   $$resp_{pk}.G_{Aff} \stackrel{?}{=} T_{pk} + PK_{Aff}.c$$
   $$\implies (sk_r + sk.c).G_{Aff} \stackrel{?}{=} sk_r.G_{Aff} + PK_{Aff}.c$$
6. For each leg $k$, verifier checks asset-id correctness using aggregated batch Schnorr verification:
   $$resp_{r_4}.G_{Enc} \stackrel{?}{=} T_{r_4} + \sum_{k} (CT_{at_k} - at.H).c^k$$
   $$\implies (r_{4_r} + \sum_{k} r_{4_k}.c^k).G_{Enc} \stackrel{?}{=} r_{4_r}.G_{Enc} + \sum_{k} (CT_{at_k} - at.H).c^k$$
7. If prover is sender in any leg, verifier checks public key correctness for all sender legs using aggregated batch Schnorr verification:
   $$resp_{pk\_send}.G_{Enc} \stackrel{?}{=} T_{pk\_send} + \sum_{k \in S} (CT_{s_k} - PK_{Aff}).c^k$$
   $$\implies (r_{1_r} + \sum_{k \in S} r_{1_k}.c^k).G_{Enc} \stackrel{?}{=} r_{1_r}.G_{Enc} + \sum_{k \in S} (CT_{s_k} - PK_{Aff}).c^k$$
8. If prover is receiver in any leg, verifier checks public key correctness for all receiver legs using aggregated batch Schnorr verification:
   $$resp_{pk\_recv}.G_{Enc} \stackrel{?}{=} T_{pk\_recv} + \sum_{k \in R} (CT_{r_k} - PK_{Aff}).c^k$$
   $$\implies (r_{2_r} + \sum_{k \in R} r_{2_k}.c^k).G_{Enc} \stackrel{?}{=} r_{2_r}.G_{Enc} + \sum_{k \in R} (CT_{r_k} - PK_{Aff}).c^k$$
9. If prover is sender in any leg, verifier checks the total sent amount:
   $$resp_{sent_v}.G_{Enc} \stackrel{?}{=} T_{sent_v} + (\sum_{k \in S} CT_{v_k} - pending\_sent.H).c$$
   $$\implies (r_{sent_v} + (\sum_{k \in S} r_{3_k}).c).G_{Enc} \stackrel{?}{=} r_{sent_v}.G_{Enc} + (\sum_{k \in S} CT_{v_k} - pending\_sent.H).c$$
10. If prover is receiver in any leg, verifier checks the total received amount:
    $$resp_{recv_v}.G_{Enc} \stackrel{?}{=} T_{recv_v} + (\sum_{k \in R} CT_{v_k} - pending\_recv.H).c$$
    $$\implies (r_{recv_v} + (\sum_{k \in R} r_{3_k}).c).G_{Enc} \stackrel{?}{=} r_{recv_v}.G_{Enc} + (\sum_{k \in R} CT_{v_k} - pending\_recv.H).c$$

