# Settlement

## Settlement

A settlement can have 1 or more **Leg**s as each Leg represents one asset transfer. Say Alice wants to send 10 units of asset id $at$ to Bob, then such a settlement will have 1 leg with Alice as sender and Bob as receiver.
If Alice wants to swap asset 10 units of $at$ with Bob for 20 units of $at'$, then such a settlement will have 2 legs with Alice acting as sender in one leg and receiver in other and vice-versa for Bob
Settlements might be created by sender, receiver or a third party. To keep the amount, and identities of parties confidential, the settlement creator encrypts these details including asset-id so that the chain does not even learn which asset is being traded. However, the chain knows how many legs the settlement has. The encryption is done for all parties to that leg which include sender, receiver and all auditors and mediators for that asset.  An assumption here is that the verifier does not need to ensure that the encryption is correctly done for the sender, receiver or mediator since they need to respond to a settlement for it to succeed so if the decryption can't be done, it will eventually fail. This isn't true for auditors and they just need to observe and can't influence the settlement anyway.
Following describes the creation of a leg, its encryption, decryption and the proof that the leg is correctly generated.

### Leg

A leg has:

1. $AK_s = sk_s.G_{Aff}$ - Affirmation key of sender
2. $AK_r = sk_r.G_{Aff}$ - Affirmation key of receiver
3. $EK_s = ek_s.G_{Enc}$ - Encryption key of sender
4. $EK_r = ek_r.G_{Enc}$ - Encryption key of receiver
5. $at$ - asset-id being transferred
6. $v$ - Amount of units being transferred
7. $keys$ - A list of keys of asset's auditors and mediators along with their role specified such that $keys_i = (role, EK_i)$ where $EK_i = sk_i.G_{Enc}$ is the key of the i-th auditor/mediator

#### Encryption
The settlement creator wants to ensure that the same leg encryption is given to all parties and thus uses twisted Elgamal.

1. Since 4 items need to be encrypted, picks $r_1, r_2, r_3, r_4 \in \mathbb{Z}_p$ and creates:
   $$CT_s = r_1.G_{Enc} + AK_s$$
   $$CT_r = r_2.G_{Enc} + AK_r$$
   $$CT_v = r_3.G_{Enc} + v.H$$
   $$CT_{at} = r_4.G_{Enc} + at.H$$
2. Above can be used by the sender/receiver to decrypt but they also need to prove (during affirmations) that $CT_s$(or $CT_r$) has $AK_s$(or $AK_r$) and they know its secret key. To make it efficient, the creator picks $r_i$ such that both sender and receiver can recover them. It does that using Diffie-Hellman as:
   Pick a random $y \in \mathbb{Z}_p$ and create a shared secret $ss = y.G_{Enc}$
   Use hash-to-field to get $(r_1, r_2, r_3, r_4) = h2f(ss)$
   Now create $Eph_s = y.EK_s$ and $Eph_r = y.EK_r$
3. Now sender (or receiver) can recover $ss$ as $ss = ek_s^{-1}.Eph_s$ (or $ss = ek_r^{-1}.Eph_r$) and then $(r_1, r_2, r_3, r_4) = h2f(ss)$
4. For each $keys_i$, create $Eph_{k_i} = [r_1.EK_i, r_2.EK_i, r_3.EK_i, r_4.EK_i]$

The leg encryption is
$$
(CT_s, CT_r, CT_v, CT_{at}, Eph_s, Eph_r, [Eph_{k_0}, Eph_{k_1}, ...])
$$

#### Decryption
If a sender/receiver knows which leg corresponds to his key (from off-chain communication), it first recovers $r_i$ as described above.

1. Then it decrypts $CT_s, CT_r$ to get its and ensure that its the correct key
   $$AK_s = CT_s - r_1.G_{Enc}$$
   $$AK_r = CT_r - r_2.G_{Enc}$$
2. To decrypt amount and asset-id, does the Elgamal decryption followed by solving discrete log $v, at$ in
   $$v.H = CT_v - r_3.G_{Enc}$$
   $$at.H = CT_{at} - r_4.G_{Enc}$$

Since $v$ and $at$ are small, 48 and 32 bits respectively, they can be recovered in reasonable amount of time solving discrete log.

if the sender/receiver didn't know which legs corresponds to him, then he has to scan the chain and repeat step 1 for each leg to check if its the sender or receiver. Note that the sender/receiver's affirmation secret key is not needed to decrypt so they can delegate the decryption task to another service without that service being able to spend their assets but it can only track them.

For auditors/mediators, who don't have $r_i$ but only their key, they proceed by taking inverse of secret key as $sk^{-1}$ and:

1. $$AK_s = CT_s - sk^{-1}.Eph_{k_i}[0] = CT_s - r_1.G_{Enc}$$
2. $$AK_r = CT_r - sk^{-1}.Eph_{k_i}[1] = CT_r - r_2.G_{Enc}$$
3. $$v.H = CT_v - sk^{-1}.Eph_{k_i}[2] = CT_v - r_3.G_{Enc}$$
4. $$at.H = CT_{at} - sk^{-1}.Eph_{k_i}[3] = CT_{at} - r_4.G_{Enc}$$

$v$ and $at$ are recovered by solving discrete log.

### Leg creation proof
The proof for leg creation needs to hide:
- The sender and receiver's identity (or public key)
- The amount being transferred
- The asset being transacted. This is the most complicated part as it needs to prove that all the transaction details are being encrypted for the asset's auditors and mediators without revealing the asset or identity of auditors and mediators.

Recall from the "System model" model section that an asset's data, i.e. its id and public keys of all its auditors and mediators are stored in a leaf of the asset curve tree. It is Pedersen commitment to the "asset-id" and x-coordinates of the public keys of auditors and mediators as
$$
Leaf_{asset\_id} = (AT.x).\widetilde{G} + (EK_1.x).\widetilde{G}_1 + (EK_2.x).\widetilde{G}_2 + ... + (EK_n.x).\widetilde{G}_n, \quad Leaf_{asset\_id} \in \mathbb{G}_q
$$

But there is a slight difference in the implementation where we include the role of the $EK_i$ as well so the leaf actually looks like this

$$
Leaf_{asset\_id} = (AT.x).\widetilde{G} + ((role_1.J + EK_1).x).\widetilde{G}_1 + ((role_2.J + EK_2).x).\widetilde{G}_2 + ... + ((role_n.J + EK_n).x).\widetilde{G}_n, \quad Leaf_{asset\_id} \in \mathbb{G}_q
$$

Here
- $(AT.x)$ refers to taking the x-coordinate of point $AT = asset\_id.J$, $A \in \mathbb{G}_p$
- $(role_i.J + EK_i.x)$ refers to taking the x-coordinate of $role_i.J + EK_i$ where $role_i$ and $EK_i$ are role and public key of the $i$-th auditor/mediator. If role is auditor, $role_i = 1$ else 0. 
  The x-coordinates are taken using the same approach as done by curve tree paper: adding a public element $\Delta$ to $EK_i$ and taking the x-coordinate of the result

Now this pushes $Leaf_{asset\_id}$ in a different group $\mathbb{G}_q$ (Vesta curve) whereas all public keys are in $\mathbb{G}_p$ (Pallas curve). We use a similar technique used by Curve tree paper. The key idea is that the asset-id and encryption keys for all auditors and mediators is committed in a single Pedersen commitment where the x-coordinate of the item "represents" the item and then we randomize each item and can treat as a group element which can be revealed. Since the $asset\_id \in \mathbb{Z}_p$, we shift it to $\mathbb{G}_p$ by multiplying it by a public $J \in \mathbb{G}_p$. Following describes the general protocol

**Pedersen Commitment to Curve Points**

Commits to elliptic curve points by committing to their x-coordinate the same way curve trees do. Then the knowledge of those committed points can be proven along with generating a re-randomized version of each point.
Given points $P_i \in \mathbb{G}_p$ as 

$$A = [P_0, P_1, ..., P_n]$$ 

Commit to $A$ in a Pedersen commitment of x-coordinate of each $P_i$, i.e. 

$$P_i.x \in C = PedCom(P_0.x, P_1.x, ..., P_n.x) = \sum_{\widetilde{G}_i*P_i.x}$$ 

where $C \in \mathbb{G}_q$ and $P_i.x \in \mathbb{Z}_q$ where $\mathbb{G}_p, \mathbb{G}_q$ are on 2 curves which form a 2-cycle (base field of one equals scalar field of other).

1. Prover randomizes each $P_i$ to get 
  $$A_r = [{P_r}_0, {P_r}_1, ..., {P_r}_n]$$
  
  where 
  
  $$A_r[i] = P_{r_i} = P_i + bl_i*B$$ 

  $$B \in \mathbb{G}_p, \quad bl_i \stackrel{\$}{\leftarrow} \mathbb{Z}_p$$.

2. Prover proves $\forall i, P_i \in \mathbb{G}_p$, i.e. $P_i.x, P_i.y$ are x and y coordinates of a point which lies in group $\mathbb{G}_p$ and $P_i.x, P_i.y \in \mathbb{Z}_q$.
3. Prover proves $\forall i, A_r[i] = A[i] + bl_i*B = P_i + bl_i*B$

The implementation adds a public element $\Delta$ to each $P_i$ as mentioned in the curve tree paper.

In our usage of the above protocol, $A$ corresponds to $[AT, role_1.J + EK_1, role_2.J + EK_2, .., role_n.J + EK_n]$

A prover (settlement creator) wants to prove following relations when creating a leg with amount $v$:

1. $CT_v, CT_{at}$ correctly encrypt the amount and asset-id
2. $Eph_{k_i} = [r_1.EK_i, r_2.EK_i, r_3.EK_i, r_4.EK_i]$ where $EK_i$ is the key of the $i$-th auditor and mediator. This also involves a curve tree membership proof as the creator needs to prove that the asset-id its proving about is a valid one (in the tree).
3. $v <= MAX\_BALANCE$


**Instance**: $CT_v$, $CT_{at}$, $Path_r$, $Root$, $G_{Enc}$, $G_i$, $H$, $H_i$, $J$, $\widetilde{G}$, $\widetilde{G}_i$, $\widetilde{H}$, $\widetilde{H}_i$

**Witness**: $v, at, r_1, r_2, r_3, r_4, EK_i, Path$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.


#### Prover
1. Prover creates list of points for asset-id and $keys$ as $$A = [AT, role_1.J + EK_1, role_2.J + EK_2, .., role_n.J + EK_n]$$
2. Create blindings $blindings = [bl_0, bl_1, bl_2, ... bl_n]$ and randomize $A$ as $$A_r = [AT_r, E_1, E_2, ..., E_n]$$ where $$AT_r = AT + bl_0.H_0 = at.J + bl_0.H_0$$ and $$E_i = role_i.J + EK_i + bl_i.H_0$$. $A_r$ will be shared with the verifier since all its items are randomized.
3. Take coordinates of all points in $A$ as $$x=[(AT + \Delta).x, (E_1 + \Delta).x, (E_2 + \Delta).x, ..., (E_n + \Delta).x]$$ and $$y = [(AT + \Delta).y, (E_1 + \Delta).y, (E_2 + \Delta).y, ..., (E_n + \Delta).y]$$
4. Enforces constraints that for each $i$:
   - $(x_i, y_i)$ is a valid curve point
   - $(x_i, y_i) + bl_i.H_0 = (x_{r_i}, y_{r_i}) + \Delta$ where $(x_{r_i}, y_{r_i}) = A_r[i]$. The RHS is completely public but the LHS involves a fixed point ($H_0$) scalar multiplication - $bl_i.H_0$ and a curve point addition - $(x_i, y_i) + bl_i.H_0$.
5. Now that there is a public $E_i$ corresponding to each public key $EK_i$ as $E_i = role_i.J + EK_i + bl_i.H_0$, we can state $EK_i$ in terms of $E_i$ as $E_i - role_i.J - bl_i.H_0 = EK_i$ since the LHS is a "blinded version" of $EK_i$ and is different for the same $EK_i$ in different proofs (as long as fresh $bl_i$ is chosen).
   Now use it for proving relations about $Eph_{k_i}$ as
   $$
   Eph_{k_i} = [r_1.(E_i - role_i.J - bl_i.H_0), r_2.(E_i - role_i.J - bl_i.H_0), r_3.(E_i - role_i.J - bl_i.H_0), r_4.(E_i - role_i.J - bl_i.H_0)]
   $$
   which is doable using folklore techniques as all group elements, $E_i, H_0, J$ are public. Infact, $role_i.J$ is public since $role_i$ is public.
6. Now prover has to use Sigma protocol for 2 witnesses for each item of $Eph_{k_i}$ which is expensive so we express
   - $Eph_{k_i}[0]$ in the relation in point 2 as $Eph_{k_i}[0] = r_1.(E_i - role_i.J) + r_1.bl_1.(-H_0)$
   - $Eph_{k_i}[1] = (r_2.r_1^{-1}).Eph_{k_i}[0]$ since $r_1^{-1}.Eph_{k_i}[0] = E_i - role_i.J - bl_i.H_0 = EK_i$
   - Similarly, $Eph_{k_i}[2] = (r_3.r_1^{-1}).Eph_{k_i}[0]$ and
   - $Eph_{k_i}[3] = (r_4.r_1^{-1}).Eph_{k_i}[0]$
7. Another trick is that prover doesn't need to prove that the scalars $r_2.r_1^{-1}, r_3.r_1^{-1}, r_4.r_1^{-1}$ are well formed in the sigma protocols. It can enforce that in Bulletproof using multiplication relations like $r_1 . r_2.r_1^{-1} = r_2$ and so on. In the sigma protocol, prover treats $r_2.r_1^{-1}, r_3.r_1^{-1}, r_4.r_1^{-1}$ as $\alpha, \beta, \gamma$.
8. For proving $AT_r = at.J + bl_0.H_0$, prover picks random $at_r, bl_{0_r} \in \mathbb{Z}_p$ and creates:
   $$T_{AT_r} = at_r.J + bl_{0_r}.H_0, \in \mathbb{G}_p$$
9. For the unified Bulletproof commitment, prover creates:
   $$
   C_{BP} = b.H_0 + r_1.H_1 + r_2.H_2 + r_3.H_3 + r_4.H_4 + \alpha.H_5 + \beta.H_6 + \gamma.H_7 + v.H_8, \quad C_{BP} \in \mathbb{G}_p
   $$
   where $\alpha = r_2.r_1^{-1}$, $\beta = r_3.r_1^{-1}$, $\gamma = r_4.r_1^{-1}$.
10. Bulletproof constraints enforce:
   - $r_1 . \alpha = r_2$
   - $r_1 . \beta = r_3$
   - $r_1 . \gamma = r_4$
   - $v <= MAX\_BALANCE$ (range proof)
11. For each auditor/mediator $i$, prover proves $$Eph_{k_i}[0] = r_1.(E_i - role_i.J) + r_1.bl_i.(-H_0)$$. Prover picks random $$r_{1_r}, bl_{i_r} \in \mathbb{Z}_p$$ and creates:
    $$T_{Eph_{k_i}[0]} = r_{1_r}.(E_i - role_i.J) + bl_{i_r}.(-H_0), \in \mathbb{G}_p$$
12. For $Eph_{k_i}[1]$, prover picks random $\alpha_r \in \mathbb{Z}_p$ and creates:
    $$T_{Eph_{k_i}[1]} = \alpha_r.Eph_{k_i}[0], \in \mathbb{G}_p$$
13. For $Eph_{k_i}[2]$, prover picks random $\beta_r \in \mathbb{Z}_p$ and creates:
    $$T_{Eph_{k_i}[2]} = \beta_r.Eph_{k_i}[0], \in \mathbb{G}_p$$
14. For $Eph_{k_i}[3]$, prover picks random $\gamma_r \in \mathbb{Z}_p$ and creates:
    $$T_{Eph_{k_i}[3]} = \gamma_r.Eph_{k_i}[0], \in \mathbb{G}_p$$
15. For the Bulletproof commitment, prover picks random $r_{BP} \in \mathbb{Z}_p$ and creates:
     $$T_{BP} = r_{BP}.H_0 + r_{1_r}.H_1 + r_{2_r}.H_2 + r_{3_r}.H_3 + r_{4_r}.H_4 + $$
     $$\alpha_r.H_5 + \beta_r.H_6 + \gamma_r.H_7 + v_r.H_8, \in \mathbb{G}_p$$
16. For proving $CT_v = r_3.G_{Enc} + v.H$ and $CT_{at} = r_4.G_{Enc} + at.H$, prover picks random $$r_{3_r}, v_r, r_{4_r}, at_r \in \mathbb{Z}_p$$ and creates:
    $$T_v = r_{3_r}.G_{Enc} + v_r.H, \in \mathbb{G}_p$$
    $$T_{at} = r_{4_r}.G_{Enc} + at_r.H, \in \mathbb{G}_p$$
17. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(A_r, Leaf_{asset\_id}, Path_r, Root, CT_v, CT_{at}, C_{BP}, $$
    $$T_{AT_r}, T_{Eph_{k_i}[0]}, T_{Eph_{k_i}[1]}, T_{Eph_{k_i}[2]}, T_{Eph_{k_i}[3]}, T_{BP}, T_v, T_{at})$$
18. Prover creates responses for $resp_{AT_r}$:
    $$resp_{AT_r} = [\begin{matrix}
    at_r + at.c, & bl_{0_r} + bl_0.c\\
    \end{matrix}]$$
19. For each $i$, prover creates responses for $resp_{Eph_{k_i}[0]}$:
    $$resp_{Eph_{k_i}[0]} = [\begin{matrix}
    r_{1_r} + r_1.c, & bl_{i_r} + r_1.bl_i.c\\
    \end{matrix}]$$
20. For $Eph_{k_i}[1]$, prover creates response:
    $resp_{Eph_{k_i}[1]} = \alpha_r + \alpha.c$
21. For $Eph_{k_i}[2]$, prover creates response:
    $resp_{Eph_{k_i}[2]} = \beta_r + \beta.c$
22. For $Eph_{k_i}[3]$, prover creates response:
    $resp_{Eph_{k_i}[3]} = \gamma_r + \gamma.c$
23. For $CT_v$, prover creates responses:
    $$resp_v = [\begin{matrix}
    r_{3_r} + r_3.c, & v_r + v.c\\
    \end{matrix}]$$
    $$resp_{at} = [\begin{matrix}
    r_{4_r} + r_4.c, & \bot \\
    \end{matrix}]$$
24. For relation $C_{BP}$, prover creates response for blinding $b$:
    $$resp_{BP} = [\begin{matrix}
    r_{BP} + b.c, & \bot, & r_{2_r} + r_2.c, & \bot, & \bot, & \bot, & \bot, & \bot, & \bot
    \end{matrix}]$$
25. The proof is
    $$(C_{BP}, A_r, Leaf_{asset\_id}, Path_r, CT_v, CT_{at}, $$
    $$T_{AT_r}, T_{Eph_{k_i}[0]}, T_{Eph_{k_i}[1]}, T_{Eph_{k_i}[2]}, T_{Eph_{k_i}[3]}, T_{BP}, T_v, T_{at}, $$
    $$resp_v, resp_{at}, resp_{AT_r}, resp_{Eph_{k_i}[0]}, resp_{Eph_{k_i}[1]}, resp_{Eph_{k_i}[2]}, resp_{Eph_{k_i}[3]}, resp_{BP},)$$

#### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$
   c = Hash(A_r, Leaf_{asset\_id}, Path_r, Root, CT_v, CT_{at}, C_{BP}, T_{AT_r}, T_{Eph_{k_i}[0]}, T_{Eph_{k_i}[1]}, T_{Eph_{k_i}[2]}, T_{Eph_{k_i}[3]}, T_{BP}, T_v, T_{at})
   $$
2. Verifier enforces the Bulletproof constraints for curve point validity: for each $i$, $(x_i, y_i)$ satisfies the curve equation.
3. Verifier enforces the Bulletproof constraints for randomization consistency: $(x_i, y_i) + bl_i.H_0 = (x_{r_i}, y_{r_i}) + \Delta$ for all $i$.
4. Verifier enforces the Bulletproof constraints for curve tree membership to verify that $Path_r$ leads to $Root$.
5. Verifier enforces the Bulletproof constraints for the multiplication relations:
   - $r_1 . \alpha = r_2$
   - $r_1 . \beta = r_3$
   - $r_1 . \gamma = r_4$
6. Verifier enforces the Bulletproof constraint for range proof: $v <= MAX\_BALANCE$.
7. Verifies correctness of $AT_r$ by checking:
   $$resp_{AT_r}[0].J + resp_{AT_r}[1].H_0 \stackrel{?}{=} T_{AT_r} + AT_r.c$$
   $$\implies (at_r + at.c).J + (bl_{0_r} + bl_0.c).H_0 \stackrel{?}{=} T_{AT_r} + AT_r.c$$

8. For each $i$, verifies correctness of $Eph_{k_i}[0]$ by checking:
   $$resp_{Eph_{k_i}[0]}[0].(E_i - role_i.J) + .resp_{Eph_{k_i}[0]}[1].(-H_0) \stackrel{?}{=} T_{Eph_{k_i}[0]} + Eph_{k_i}[0].c$$
   $$\implies (r_{1_r} + r_1.c).(E_i - role_i.J) + (bl_{i_r} + r_1.bl_i.c).(-H_0) \stackrel{?}{=} T_{Eph_{k_i}[0]} + Eph_{k_i}[0].c$$

9. For each $i$, verifies correctness of $Eph_{k_i}[1]$ by checking:
   $$resp_{Eph_{k_i}[1]}.Eph_{k_i}[0] \stackrel{?}{=} T_{Eph_{k_i}[1]} + Eph_{k_i}[1].c$$
   $$\implies (\alpha_r + \alpha.c).Eph_{k_i}[0] \stackrel{?}{=} T_{Eph_{k_i}[1]} + Eph_{k_i}[1].c$$

10. For each $i$, verifies correctness of $Eph_{k_i}[2]$ by checking:
    $$resp_{Eph_{k_i}[2]}.Eph_{k_i}[0] \stackrel{?}{=} T_{Eph_{k_i}[2]} + Eph_{k_i}[2].c$$
    $$\implies (\beta_r + \beta.c).Eph_{k_i}[0] \stackrel{?}{=} T_{Eph_{k_i}[2]} + Eph_{k_i}[2].c$$

11. For each $i$, verifies correctness of $Eph_{k_i}[3]$ by checking:
    $$resp_{Eph_{k_i}[3]}.Eph_{k_i}[0] \stackrel{?}{=} T_{Eph_{k_i}[3]} + Eph_{k_i}[3].c$$
    $$\implies (\gamma_r + \gamma.c).Eph_{k_i}[0] \stackrel{?}{=} T_{Eph_{k_i}[3]} + Eph_{k_i}[3].c$$

12. Verifier checks response for $C_{BP}$ as:
    $$resp_{BP}[0].H_0 + resp_{Eph_{k_i}[0]}[0].H_1 + resp_{BP}[2].H_2 + resp_v[0].H_3 + resp_{at}[0].H_4 + $$
    $$resp_{Eph_{k_i}[1]}.H_5 + resp_{Eph_{k_i}[2]}.H_6 + resp_{Eph_{k_i}[3]}.H_7 + resp_v[1].H_8 \stackrel{?}{=} T_{BP} + C_{BP}.c$$
    $$\implies (r_{BP} + b.c).H_0 + (r_{1_r} + r_1.c).H_1 + (r_{2_r} + r_2.c).H_2 + (r_{3_r} + r_3.c).H_3 + (r_{4_r} + r_4.c).H_4 + $$
    $$(\alpha_r + \alpha.c).H_5 + (\beta_r + \beta.c).H_6 + (\gamma_r + \gamma.c).H_7 + (v_r + v.c).H_8 \stackrel{?}{=} T_{BP} + C_{BP}.c$$

13. Verifies correctness of $CT_v$ by checking:
    $$resp_v[0].G_{Enc} + resp_v[1].H \stackrel{?}{=} T_v + CT_v.c$$
    $$\implies (r_{3_r} + r_3.c).G_{Enc} + (v_r + v.c).H \stackrel{?}{=} T_v + CT_v.c$$

14. Verifies correctness of $CT_{at}$ by checking:
    $$resp_{at}[0].G_{Enc} + resp_{at}[1].H \stackrel{?}{=} T_{at} + CT_{at}.c$$
    $$\implies (r_{4_r} + r_4.c).G_{Enc} + (at_r + at.c).H \stackrel{?}{=} T_{at} + CT_{at}.c$$

15. Verifier finally checks the Bulletproofs proof for all constraints i.e. curve point validity, randomization consistency, curve tree membership, multiplication relations, and range proof