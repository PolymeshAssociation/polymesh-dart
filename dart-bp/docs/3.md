# Asset Minting

## Asset minting
This process is done by an issuer who wants to mint some quantity of an asset that he created into his own account. The asset-id is public and so is the minted amount. Issuer's key $AK$ and it identity $id$ are also public. The chain ensures that the total minted amount can never exceed $MAX\_BALANCE$ and thus there is no range proof required on the balance in the new state.

A successful completion of minting results in the following:

1. The issuer's old account state $State_{old}$ is invalidated and new state $State_{new}$ is created. However, $State_{old}$ cannot be revealed as it identifies which account state is being invalidated. So a randomized version of it $State_{old_r}$ is used in relations.
2. Nullifier $N=\rho_i.G_5$ is revealed by issuer and chain adds it to the nullifier set. Here $\rho_i$ refers to the nullifier secret key of $State_{old}$
3. The balance in $State_{new}$ is more than balance in $State_{old}$ by the minted amount
4. $State_{new}$ is inserted as a new leaf in the curve tree.

### Protocol
Here the prover (issuer) wants to prove following relations when minting amount $v$:

1. $State_{old} = sk.G_{Aff} + bal_0.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7$. This is equivalent to proving $State_{old} = AK + bal_0.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^i.G_5 + s^j.G_6 + id.G_7$ since public key $AK$ is revealed to the verifier.
2. Similarly $State_{new} = AK + bal_1.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$. Since $bal_0 = v + bal_1$, this is equivalent to $State_{new} - v.G_1 = AK + bal_0.G_1 + cnt.G_2 + at.G_3 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 + id.G_7$
3. $State_{old}$ exists in the accumulator (account curve tree)
4. $N = \rho^i.G_5$
5. $AK = sk.G_{Aff}$
6. $\rho^{i+1} = \rho.\rho^i$
7. $s^{2.j} = s^j.s^j$
8. $bal_1 = bal_0 + v$

**Instance**: $State_{old_r}, State_{new}, AK, at, N, id, v, Path_r, Root, G_{Aff}, G_i, H_i, \widetilde{G}, \widetilde{G}_i, \widetilde{H}, \widetilde{H}_i \in \mathbb{G}_q$

**Witness**: $sk, bal_0, bal_1, cnt, \rho, \rho^i, \rho^{i+1}, s^j, s^{2.j}, Path$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

#### Prover
1. Prover first wants to prove knowledge of $bal_0, cnt, \rho, \rho^i, s^j$ in the relation $bal_0.G_1 + cnt.G_2 + \rho.G_4 + s^j.G_6 = State_{old} - AK - at.G_3 - N - id.G_7$. This is just relation 1 from above rearranged where values on RHS are public except $State_{old}$. Now prover cannot reveal $State_{old}$. Point 5 below explains how.
2. Similarly, taking relation 2 from above, prover wants to prove knowledge of $bal_0, c, \rho, \rho^{i+1}, s^{2.j}$ in $bal_0.G_1 + cnt.G_2 + \rho.G_4 + \rho^{i+1}.G_5 + s^{2.j}.G_6 = D$ where $D = State_{new} - v.G_1 - AK - at.G_3 - id.G_7$.
3. Prover creates nullifier $N = \rho^i.G_5$
4. Prover gets the path of the leaf $State_{old}$ as $Path$, an array of nodes (curve points), and randomizes it, i.e all nodes in the path have a blinding added to them like $b_i*H_0$ or $b_i*\widetilde{H}_0$. This will result in the leaf $State_{old}$ being transformed into $State_{old_r} = State_{old} + b_0.H_0$ and $Path$ transforms into $Path_r$.
   Prover enforces the constraints for curve tree membership using $Path, Path_r, b_i$
5. Since prover knows the opening of $State_{old}$ and $b_0$, it can prove the knowledge of opening of $State_{old_r}$ as well. So relation 1 can be transformed as
   $$
   bal_0.G_1 + cnt.G_2 + \rho.G_4 + \rho^i.G_5 + s^j.G_6  + b_0.H_0 = State_{old_r} - AK - at.G_3 - N - id.G_7
   $$
   where the RHS is public. Now it starts proving the knowledge of these.
6. Prover picks random $sk_{blinding}, cnt_{blinding}, bal_{0_{blinding}}, \rho_{blinding}, \rho_{i_{blinding}}, \rho_{i+1_{blinding}}, s^j_{blinding}, s^{2.j}_{blinding}, b_{0_{blinding}} \in \mathbb{Z}_p$ and creates:
   $$
   T_{State_{old_r}} = bal_{0_{blinding}}.G_1 + cnt_{blinding}.G_2 + \rho_{blinding}.G_4 + \rho_{i_{blinding}}.G_5 + s^j_{blinding}.G_6  + b_{0_{blinding}}.H_0, \in \mathbb{G}_p
   $$
   $$
   T_{State_{new}} = bal_{0_{blinding}}.G_1 + cnt_{blinding}.G_2 + \rho_{blinding}.G_4 + \rho_{i+1_{blinding}}.G_5 + s^{2.j}_{blinding}.G_6, \in \mathbb{G}_p
   $$

   Same blinding $bal_{0_{blinding}}$ is used for both old and new balance since the change in balance is public and can thus be used in verification check accordingly.
7. For the correctness of nullifier and knowledge of secret key, prover creates
   $T_{null} = \rho_{i_{blinding}}.G_5, \in \mathbb{G}_p$
   $T_{pk} = sk_{blinding}.G_{Aff}, \in \mathbb{G}_p$
8. For enforcing, $\rho^{i+1} = \rho.\rho^i$, $s^{2.j} = s^j.s^j$, prover setups the constraints in Bulletproof as both of these are just multiplications. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of committed values in Bulletproof's commitment (corresponding to its witnesses) and in $State_{old}, \text{and}, State_{new}$. Let $C_{BP_{\rho,s}}$ be the commitment to these values:
   $$C_{BP_{\rho,s}} = b'.H_0 + \rho.H_1 + \rho^i.H_2 + \rho^{i+1}.H_3 + s^j.H_4 + s^{2.j}.H_5, \in \mathbb{G}_p$$
   Here $b'$ is the blinding to the commitment added by Bulletproof.
9. Prover proves knowledge of above committed values and equality of these with other commitments as:
   Pick random $r_{BP_{\rho,s}} \in \mathbb{Z}_p$ and create
   $$T_{BP_{\rho,s}} = r_{BP_{\rho,s}}.H_0 + \rho_{blinding}.H_1 + \rho_{i_{blinding}}.H_2 + \rho_{i+1_{blinding}}.H_3 + s^j_{blinding}.H_4 + s^{2.j}_{blinding}.H_5, \in \mathbb{G}_p$$
10. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_{old_r}, State_{new}, AK, at, N, id, v, Path_r, Root, C_{BP_{\rho,s}}, T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{pk})$$
11. Prover now creates responses for sigma protocol for $Resp_{state_{old_r}}$:
    $$Resp_{state_{old_r}} = [\begin{matrix}
    bal_{0_{blinding}} + bal_0.c, & cnt_{blinding} + cnt.c, & \rho_{blinding} + \rho.c, & \rho_{i_{blinding}} + \rho_i.c, & s_{j_{blinding}} + s_j.c, & b_{0_{blinding}} + b_0.c\\
    \end{matrix}]$$
12. Responses for sigma protocol for $Resp_{state_{new}}$:
    $$Resp_{state_{new}} = [\begin{matrix}
    \bot, & \bot, & \bot, & \rho_{i+1_{blinding}} + \rho_{i+1}.c, & s_{2.j_{blinding}} + s_{2.j}.c\\
    \end{matrix}]$$
    
    The symbol $\bot$ indicates that no response is created for that witness since a response has been created for the same witness above. Because responses for $bal_1, cnt$ and $\rho$ are already created in $Resp_{state_{old_r}}$.
13. The response for nullifier secret key $\rho^i$ is already created in $Resp_{state_{old_r}}$. Response for witness $sk$
    $Resp_{pk} = sk_{blinding} + sk.c$
14. For relation $C_{BP_{\rho,s}}$, only the response for witnesses $b'$ needs to be created as the responses of other witnesses are already created in $Resp_{state_{old_r}}$ and $Resp_{state_{new}}$.
    $Resp_{b'} = r_{BP_{\rho,s}} + b'.c$
15. The proof is
    $$
    (C_{BP_{\rho,s}}, State_{old_r}, State_{new}, Path_r, T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{pk}, Resp_{state_{old_r}}, Resp_{state_{new}}, Resp_{pk}, Resp_{b'})
    $$

#### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$c = Hash(State_{old_r}, State_{new}, AK, at, N, id, v, Path_r, Root, C_{BP_{\rho,s}}, T_{State_{old_r}}, T_{State_{new}}, T_{null}, T_{BP_{\rho,s}}, T_{pk})$$

2. Verifier enforces the Bulletproof constraints for the 2 multiplications: $\rho^{i+1} = \rho.\rho^i$ and $s^{2.j} = s^j.s^j$.

3. Verifier enforces the Bulletproof constraints for curve tree membership to verify that $Path_r$ leads to $Root$.

4. Verifies correctness of $State_{old_r}$ by checking:
   $$Resp_{state_{old_r}}[0].G_1 + Resp_{state_{old_r}}[1].G_2 + Resp_{state_{old_r}}[2].G_4 + Resp_{state_{old_r}}[3].G_5 + Resp_{state_{old_r}}[4].G_6 + Resp_{state_{old_r}}[5].H_0 \stackrel{?}{=} T_{State_{old_r}} + State_{old_r} - AK - at.G_3 - N - id.G_7.c$$

$$\implies (bal_{0_{blinding}} + bal_0.c).G_1 + (cnt_{blinding} + cnt.c).G_2 + (\rho_{blinding} + \rho.c).G_4 + (\rho_{i_{blinding}} + \rho_i.c).G_5 + (s^j_{blinding} + s^j.c).G_6 + (b_{0_{blinding}} + b_0.c).H_0 \stackrel{?}{=} T_{State_{old_r}} + (State_{old_r} - AK - at.G_3 - N - id.G_7).c$$

5. Verifies correctness of $State_{new}$ by checking:
   $$Resp_{state_{old_r}}[0].G_1 + Resp_{state_{old_r}}[1].G_2 + Resp_{state_{old_r}}[2].G_4 + Resp_{state_{new}}[3].G_5 + Resp_{state_{new}}[4].G_6 \stackrel{?}{=} T_{State_{new}} + (State_{new} - v.G_1 - AK - at.G_3 - id.G_7).c$$
   $$\implies (bal_{0_{blinding}} + bal_0.c).G_1 + (cnt_{blinding} + cnt.c).G_2 + (\rho_{blinding} + \rho.c).G_4 + (\rho_{i+1_{blinding}} + \rho_{i+1}.c).G_5 + (s^{2.j}_{blinding} + s^{2.j}.c).G_6 \stackrel{?}{=} T_{State_{new}} + (State_{new} - v.G_1 - AK - at.G_3 - id.G_7).c$$

   Note that for the $bal_0, cnt,$ and $\rho$ witnesses, verifier reuses responses from $Resp_{state_{old_r}}$.

6. Verifies correctness of nullifier by checking:
   $$Resp_{state_{old_r}}[3].G_5 \stackrel{?}{=} T_{null} + N.c$$
   $$\implies (\rho_{i_{blinding}} + \rho_i.c).G_5 \stackrel{?}{=} T_{null} + N.c$$

7. Verifies knowledge of secret key by checking:
   $$Resp_{pk}.G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$$
   $$\implies (sk_{blinding} + sk.c).G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$$

8. Verifier checks response for $C_{BP_{\rho,s}}$ as:
   $$Resp_{b'}.H_0 + Resp_{state_{old_r}}[2].H_1 + Resp_{state_{old_r}}[3].H_2 + Resp_{state_{new}}[3].H_3 + Resp_{state_{old_r}}[4].H_4 + Resp_{state_{new}}[4].H_5 \stackrel{?}{=} T_{BP_{\rho,s}} + C_{BP_{\rho,s}}.c$$
   $$\implies (r_{BP_{\rho,s}} + b'.c).H_0 + (\rho_{blinding} + \rho.c).H_1 + (\rho_{i_{blinding}} + \rho_i.c).H_2 + (\rho_{i+1_{blinding}} + \rho_{i+1}.c).H_3 + (s^j_{blinding} + s^j.c).H_4 + (s^{2.j}_{blinding} + s^{2.j}.c).H_5 \stackrel{?}{=} T_{BP_{\rho,s}} + C_{BP_{\rho,s}}.c$$

9. Verifier finally checks the Bulletproofs proof for all constraints i.e. curve tree membership and multiplications