# Registrations

## Key registration
This is the first step where all entities, investors, auditors, mediators, register their keys. This is not registration for an asset but a proof of knowledge of secret key for the public key. A simple implementation of this is a proof of knowledge of the discrete log in these 2 relations which can be done with a folklore sigma protocol (Schnorr):
$$
EK = ek.G_{Enc}, \quad AK = sk.G_{Aff}
$$

But since we allow users (think institutions) to onboard a large number of keys in a single txn, we use the batch Schnorr protocol from Fig. 2 of [this paper](https://iacr.org/archive/asiacrypt2004/33290273/33290273.pdf) (Fig. 2 has a typo in the last equation where $g^y$ should be $g^s$) and implement the key registration as:

1. Prover (user) wants to register the public keys $[(EK_1, AK_1), (EK_2, AK_2), ... (EK_n, AK_n)]$ and has the corresponding secret keys $[(ek_1, sk_1), (ek_2, sk_2), ..., (ek_n, sk_n)]$
2. Prover picks random:

   $$r_{enc} \stackrel{\$}{\leftarrow} \mathbb{Z}_p$$

   $$r_{aff} \stackrel{\$}{\leftarrow} \mathbb{Z}_p$$

3. Prover creates $T_{enc} = r_{enc}.G_{Enc}, \quad T_{aff} = r_{aff}.G_{Aff}$
4. Prover hashes $[(EK_1, AK_1), (EK_2, AK_2), ... (EK_n, AK_n)]$, $T_{enc}, T_{aff}$ to get a challenge $c \in \mathbb{Z}_p$
5. Prover creates responses as:

   $$s_{enc} = r_{enc} + \sum_{i=1}^n c^i.ek_i$$

   $$s_{aff} = r_{aff} + \sum_{i=1}^n c^i.sk_i$$

6. Verifier now checks:

   $$s_{enc}.G_{Enc} \stackrel{?}{=} T_{enc} + \sum_{i=1}^n c^i.EK_i$$

   $$s_{aff}.G_{Aff} \stackrel{?}{=} T_{aff} + \sum_{i=1}^n c^i.AK_i$$

Similarly, multiple encryption keys of auditors/mediators can be registered in one key registration proof by following the protocol above and ignoring $AK_i$ and corresponding relations

## Account registration
This process is used by an investor when it wants to start trading in an asset, i.e. be either a sender or receiver of that asset. It can only be done once by any public key for a particular asset and is done only for non-fee assets. The public key $PK_{Aff}$ must already be registered as per the above protocol
A successful completion of registration results in the following:

1. A state $State_0$ being inserted as a leaf in the accounts curve tree where
   $$
   State_0 = sk.G_{Aff} + asset\_id.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7
   $$
   $balance$ and $counter$ are 0 during registration
2. Pair asset-id, public key $(asset\_id, PK_{Aff}(=sk.G_{Aff}))$ is added to the Asset-account mapping
3. Nullifier $N=\rho.G_4$ is revealed by user and chain adds it to the nullifier set.
4. If asset has a trustee with public key $pk_T$, encryption of $s$ for $pk_T$ is published on chain.

**Account creation**

1. User picks a nonce $ctr$, appends to the asset-id $at$ to get the combined value $at||ctr$. It then passes it secret key $sk$ and $at||ctr$ to Poseidon2 hash to get the nullifier secret key $\rho = Poseidon2(sk, at||ctr)$. The nonce $ctr$ is used in case user wants to re-register (account recovery, etc), it can generate a new $\rho$
2. User picks a random:
   
   $$s \stackrel{\$}{\leftarrow} \mathbb{Z}_p$$
   
3. It now creates its initial account state $State_0 = sk.G_{Aff} + asset\_id.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7$


### Protocol
Here the prover (investor) wants to prove following relations:

1. $State_0 = sk.G_{Aff} + at.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7$. This is equivalent to proving $State_0 = AK + at.G_3 + N + \rho^2.G_5 + s.G_6 + id.G_7$ since $N$ and public key $AK$ is revealed to the verifier.
2. $N = \rho.G_4$
3. $\rho = Poseidon2(sk, at||ctr)$
4. $\rho^2 = \rho.\rho$
5. $AK = sk.G_{Aff}$
6. If asset has associated $pk_T$, then ciphertext $C$ correctly encrypts $s$. Since $s \in \mathbb{Z}_p$ (belongs to scalar field of Pallas curve) and is large, 255-bit in our case, if its just encrypted in exponent-Elgamal, the decryption will be impractical since the decryptor ($pk_T$) has to solve discrete log of a 255-bit value.
   Thus prover breaks it into small chunks and encrypts each chunk using exponent-Elgamal encryption. These chunks are small enough so that discrete log over them can be completed in reasonable time (few minutes). $CHUNK\_BITS$ denotes the bit size of each chunk and $NUM\_CHUNKS$ denotes the total number of chunks. In our implementation, $CHUNK\_BITS$ = 48 and $NUM\_CHUNKS$ = 6 since $\lceil {\frac{255}{48}} \rceil = 6$ and this means 6 chunks are sufficient to encode the 255-bit value
   Since Elgamal is homomorphic, these encryptions of chunks can be combined to get an encryption of the whole $s$ which can then be used in a Sigma protocol to show its equality with the $s$ used in account state $State_0$


Following describes the protocol assuming a $pk_T$ exists but its simple to avoid corresponding parts of the proof if asset does not have $pk_T$

**Instance**: $State_0, AK, at, ctr, N, id, C_i, pk_T, G_{Aff}, G_{Enc}, G_i, H_i$

**Witness**: $sk, \rho, s, s_{\mathrm{chunks}_i}, r_{\mathrm{enc}_i}$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

#### Prover
1. Prover first wants to prove knowledge of $\rho^2, s$ in the relation $$\rho^2.G_5 + s.G_6 = State_0 - AK - at.G_3 - N - id.G_7$$. This is just relation 1 from above rearranged where values on RHS are public. Lets call these $D$ as $$D = State_0 - AK - at.G_3 - N - id.G_7$$
   So prover wants to prove knowledge of $\rho^2, s$ in $\rho^2.G_5 + s.G_6 = D$ and will do with a Sigma protocol
2. Prover picks random $\rho_r, \rho^2_r, s_r \in \mathbb{Z}_p$ and creates
   $$T_{state} = \rho^2_r.G_5 + s_r.G_6$$
   $$T_{null} = \rho_r.G_4$$
3. And to prove knowledge of secret key in its affirmation key $AK$, it picks random $sk_r$ and creates $T_{pk} = sk_r.G_{Aff}$
4. If $pk_T$ exists, break randomness $s$ in $NUM\_CHUNKS$ chunks with each chunk as $CHUNK_BITS$ bit long and encrypt each using exponent Elgamal as:
   $$
   C_i = (C_{i,0}, C_{i,1}) = (r_{\mathrm{enc}_i}.G_{\mathrm{Enc}}, r_{\mathrm{enc}_i}.pk_T + s_{\mathrm{chunks}_i}.G), \quad C_i \in \mathbb{G}^2_p
   $$
   where $C_i$ is ciphertext of $i$-th chunk, $s_{chunks}$ is the base-$2^{CHUNK\_BITS}$ representation of $s$ and it has $NUM\_CHUNKS$ digits and $r_{enc_i} \in \mathbb{Z}_p$ is the randomness for the encryption.
5. Taking a linear combination of ciphertexts as below
   $$Com_s = \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot C_{i,1} = \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot r_{\mathrm{enc}_i} \cdot pk_T + s \cdot G$$
   $$Com_r = \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot C_{i,0} = \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot r_{\mathrm{enc}_i} \cdot G_{\mathrm{Enc}}$$
   Note that the scalar multiple of $pk_T$ in $Com_s$ is same as the multiple of $G_{Enc}$ in $Com_r$ and that multiple of $G$ is $s$. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of both multiples:
   Pick random $r_{combined} \in \mathbb{Z}_p$ and reuse for $s$ and create $$T_{r-combined} = r_{combined}.G_{Enc}, \quad T_{s-combined} = r_{combined}.pk_T + s_r.G$$, where $T_{r-combined}, T_{s-combined} \in \mathbb{G}_p$
6. The prover also needs to prove that each $s_{\mathrm{chunks}_i}$ is a $CHUNK\_BITS$-bit value else it can create large values for $s_{\mathrm{chunks}_i}$ which are valid base-$2^{\mathrm{CHUNK\_BITS}}$ representation digits but are so large that can't be practically retrieved using discrete log solving algorithms. For this the prover uses Bulletproofs and enforces range proof constraints for each $s_{\mathrm{chunk}_i}$
7. For proving knowledge of $r_{\mathrm{enc}_i}, s_{\mathrm{chunks}_i}$ the prover initializes Sigma protocols, 2 for each chunk. It first creates blindings and the commits to them as
   For $i$-th chunk, pick random $r_{(\mathrm{enc}_i)_r}, s_{(\mathrm{chunks}_i)_r} \in \mathbb{Z}_p$ and create $$T_{\mathrm{enc}_i} = r_{(\mathrm{enc}_i)_r}.G_{\mathrm{Enc}}, \quad T_{\mathrm{chunks}_i} = r_{(\mathrm{enc}_i)_r}.pk_T + s_{(\mathrm{chunks}_i)_r}.G$$, where $T_{\mathrm{enc}_i}, T_{\mathrm{chunks}_i} \in \mathbb{G}_p$
8. For proving $\rho = Poseidon2(sk, at||ctr)$ and $\rho^2 = \rho*\rho$, prover uses Bulletproofs constraints for Poseidon2 and a multiplication
9. Prover needs to prove that Bulletproofs constraints used in steps 5, and 7 do indeed enforce on $sk, s_{chunks_i}, \rho, \text{and}, \rho^2$. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of committed values in Bulletproof's commitment (corresponding to its witnesses) and in $State_0, \text{and}, C_i$. Let $C_{BP_\rho}$ and $C_s$ be Bulletproof's commitments to these values:
   
   $$
   C_{BP_\rho} = b.H_0 + sk.H_1 + \rho.H_2 + \rho^2.H_3, \in \mathbb{G}_p
   $$
   
   $$
   C_{BP_s} = b'.H_0 + s_{chunks_0}.H_1 + s_{chunks_1}.H_2 + ... +  s_{chunks_{NUM\_CHUNKS-1}}.H_{NUM\_CHUNKS}, \in \mathbb{G}_p
   $$
   
   Here $b, b'$ are blindings to the commitment added by Bulletproof.
10. Prover proves knowledge of above committed values and equality of these with other commitments as:
   Pick random $r_{BP_\rho} \in \mathbb{Z}_p$ and $r_{BP_s} \in \mathbb{Z}_p$ and create
   
   $$
   T_{BP_\rho} = r_{BP_\rho}.H_0 + sk_r.H_1 + \rho_r.H_2 + \rho^2_r.H_3, \in \mathbb{G}_p
   $$
   
   $$T_{BP_s} = r_{BP_s}.H_0 + s_{(\mathrm{chunks}_0)_r}.H_1 + s_{(\mathrm{chunks}_1)_r}.H_2 + ... + $$
   $$s_{(\mathrm{chunks}_{NUM\_CHUNKS-1})_r}.H_{NUM\_CHUNKS}, \in \mathbb{G}_p$$

11. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_0, AK, at, ctr, N, id, C_i, pk_T, Com_s, Com_r, C_{BP_\rho}, C_{BP_s}, $$
    $$T_{state}, T_{null}, T_{r-combined}, T_{s-combined}, T_{enc_i}, T_{chunks_i}, T_{BP_\rho}, T_{BP_s}, T_{pk})$$
12. Prover now creates responses for each sigma protocol as:
    $$resp_{state} = [\begin{matrix}
    \rho^2_r + \rho^2.c, & s_r + s.c\\
    \end{matrix}]$$
    $$resp_{pk} = sk_r + sk.c$$
    $$resp_{null} = \rho_r + \rho.c$$
    $$resp_r = r_{combined} + \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot r_{\mathrm{enc}_i} \cdot c$$
    Note that since prover already created response for witness $s$ as $s_r + s.c$ in $resp_{state}$, it has both responses for $Com_s$.
13. Creates responses for $C_i$:
    $resp_{i,0} = r_{(\mathrm{enc}_i)_r} + r_{\mathrm{enc}_i}.c$
    $resp_{s_{\mathrm{chunks}_i}} = s_{(\mathrm{chunks}_i)_r} + s_{\mathrm{chunks}_i}.c$
    Note that $resp_{i,0}$ is used as well for checking relation $C_{i, 1}$
14. For relations, $C_{BP_\rho}, C_{BP_s}$, only the responses for witnesses $b, b'$ need to be created as the responses of other witnesses are already created.
    $$resp_b = r_{BP_\rho} + b.c$$
    $$resp_{b'} = r_{BP_s} + b'.c$$
15. The proof is
    $$(C_{BP_\rho}, C_{BP_s}, $$
    $$T_{state}, T_{null}, T_{r-combined}, T_{s-combined}, T_{enc_i}, T_{chunks_i}, T_{BP_\rho}, T_{BP_s}, T_{pk}, $$
    $$resp_{state}, resp_{pk}, resp_{null}, resp_r, resp_{i,0}, resp_{s_{chunks_i}}, resp_b, resp_{b'})$$
    
#### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$c = Hash(State_0, AK, at, ctr, N, id, C_i, pk_T, Com_s, Com_r, C_{BP_\rho}, C_{BP_s}, $$
   $$T_{state}, T_{null}, T_{r-combined}, T_{s-combined}, T_{enc_i}, T_{chunks_i}, T_{BP_\rho}, T_{BP_s}, T_{pk})
   $$
2. Enforces constraints in Bulletproof for Poseidon2 and a multiplication for $\rho$ generation and $\rho^2 = \rho.\rho$ respectively
3. Enforces constraints in Bulletproof for $NUM\_CHUNKS$ range proofs, one for each chunk.
4. Verifies correctness of $State_0$ by checking:
   $$resp_{state}[0].G_5 + resp_{state}[1].G_6\stackrel{?}{=} T_{state} + State_0.c$$
   $$\implies (\rho^2_r + \rho^2.c).G_5 + (s_r + s.c).G_6 \stackrel{?}{=} \rho^2_r.G_5 + s_r.G_6 + State_0.c$$
5. Verifies correctness of $pk$ by checking:
   $$resp_{pk}.G_{Aff}\stackrel{?}{=} T_{pk} + AK.c$$
   $$\implies (sk_r + sk.c).G_{Aff} \stackrel{?}{=} sk_r.G_{Aff} + AK.c$$
6. Verifies correctness of $N$ by checking:
   $$resp_{null}.G_4 \stackrel{?}{=} T_{null} + N.c$$
   $$\implies (\rho_r + \rho.c).G_4 \stackrel{?}{=} \rho_r.G_4 + N.c$$
7. Verifier creates $Com_r$ and $Com_s$ as:
   $$Com_r = \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot C_{i,0}$$
   $$Com_s = \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot C_{i,1}$$
8. Verifies correctness of $Com_r$ by checking:
   $$resp_r.G_{enc} \stackrel{?}{=} T_{r-combined} + Com_r.c$$
   $$\implies (r_{combined} + \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot r_{\mathrm{enc}_i} \cdot c) \cdot G_{\mathrm{enc}} \stackrel{?}{=} r_{combined}.G_{\mathrm{enc}} + Com_r \cdot c$$
9. Verifies correctness of $Com_s$ by checking:
   $$resp_r.pk_T + resp_{state}[1].G \stackrel{?}{=} T_{s-combined} + Com_s.c$$
   $$\implies (r_{combined} + \sum_{i} 2^{i \cdot \mathrm{CHUNK\_BITS}} \cdot r_{\mathrm{enc}_i} \cdot c) \cdot pk_T + (s_r + s \cdot c) \cdot G \stackrel{?}{=} r_{combined}.pk_T + s_r.G + Com_s \cdot c$$
10. Verifier checks response for $C_{i,0}$ as:
    $$resp_{i,0}.G_{Enc} \stackrel{?}{=} T_{enc_i} + C_{i,0}.c$$
    $$\implies (r_{(\mathrm{enc}_i)_r} + r_{\mathrm{enc}_i}.c).G_{Enc} \stackrel{?}{=} r_{(\mathrm{enc}_i)_r}.G_{Enc} + C_{i,0}.c$$
11. Verifier checks response for $C_{i,1}$ as:
    $$resp_{i,0}.pk_T + resp_{s_{\mathrm{chunks}_i}}.G \stackrel{?}{=} T_{chunks_i} + C_{i,1}.c$$  
    $$\implies (r_{(\mathrm{enc}_i)_r} + r_{\mathrm{enc}_i}.c).pk_T + (s_{(\mathrm{chunks}_i)_r} + s_{\mathrm{chunks}_i}.c).G \stackrel{?}{=} r_{(\mathrm{enc}_i)_r}.pk_T + s_{(\mathrm{chunks}_i)_r}.G + C_{i,1}.c$$
12. Verifier checks response for $C_{BP_\rho}$ as:
    $$resp_b.H_0 + resp_{pk}.H_1 + resp_{null}.H_2 + resp_{state}[0].H_3 \stackrel{?}{=} T_{BP_\rho} + C_{BP_\rho}.c$$
    $$\implies (r_{BP_\rho} + b.c).H_0 + (sk_r + sk.c).H_1 + (\rho_r + \rho.c).H_2 + (\rho^2_r + \rho^2.c).H_3 \stackrel{?}{=} r_{BP_\rho}.H_0 + sk_r.H_1 + \rho_r.H_2 + \rho^2_r.H_3 + C_{BP_\rho}.c$$
13. Verifier checks response for $C_{BP_s}$ as:
    $$resp_{b'}.H_0 + resp_{s_{\mathrm{chunks}_0}}.H_1 + resp_{s_{\mathrm{chunks}_1}}.H_2 + ... + resp_{s_{\mathrm{chunks}_{NUM\_CHUNKS-1}}}.H_{NUM\_CHUNKS} \stackrel{?}{=} T_{BP_s} + C_{BP_s}.c$$
    $$\implies (r_{BP_s} + b'.c).H_0 + $$
    $$(s_{(\mathrm{chunks}_0)_r} + s_{\mathrm{chunks}_0}.c).H_1 + (s_{(\mathrm{chunks}_1)_r} + s_{\mathrm{chunks}_1}.c).H_2 + ... + $$
    $$(s_{(\mathrm{chunks}_{NUM\_CHUNKS-1})_r} + s_{\mathrm{chunks}_{NUM\_CHUNKS-1}}.c).H_{NUM\_CHUNKS} \stackrel{?}{=} r_{BP_s}.H_0 + $$
    $$s_{(\mathrm{chunks}_0)_r}.H_1 + s_{(\mathrm{chunks}_1)_r}.H_2 + ... + s_{(\mathrm{chunks}_{NUM\_CHUNKS-1})_r}.H_{NUM\_CHUNKS} + C_{BP_s}.c$$
14. Verifier finally checks the Bulletproofs proof that verifies all constraints, i.e for Poseidon2, multiplication and range proofs

-----------------------------------------

