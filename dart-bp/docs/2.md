## Account registration
This process is used by an investor when it wants to start trading in an asset, i.e. be either a sender or receiver of that asset. It can only be done once by any public key for a particular asset and is done only for non-fee assets. The public key $PK_{Aff}$ must already be registered as per the above protocol
A successful completion of registration results in the following:
1. A state $State_0$ being inserted as a leaf in the accounts curve tree where
   $$
   State_0 = sk.G_{Aff} + asset\_id.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7, \quad \text{balance and counter are 0 during registration}
   $$
2. Pair asset-id, public key $(asset\_id$, $PK_{Aff}(=sk.G_{Aff}))$ is added to the Asset-account mapping
3. Nullifier $N=\rho.G_4$ is revealed by user and chain adds it to the nullifier set.
4. If asset has a trustee with public key $pk_T$, encryption of $s$ for $pk_T$ is published on chain.

**Account creation**
1. User picks a nonce $c$, appends to the asset-id $at$ to get the combined value $at||c$. It then passes it secret key $sk$ and $at||c$ to Poseidon2 hash to get the nullifier secret key $\rho = Poseidon2(sk, at||c)$. The nonce $c$ is used in case user wants to re-register (account recovery, etc), it can generate a new $\rho$
2. User picks a random $$s \stackrel{\$}{\leftarrow} \mathbb{Z}_p$$
3. It now creates its initial account state $State_0 = sk.G_{Aff} + asset\_id.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7$


### Protocol
Here the prover (investor) wants to prove following relations:
1. $State_0 = sk.G_{Aff} + at.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7$. This is equivalent to proving $State_0 = AK + at.G_3 + N + \rho^2.G_5 + s.G_6 + id.G_7$ since $N$ and public key $AK$ is revealed to the verifier.
2. $N = \rho.G_4$
3. $\rho = Poseidon2(sk, at||c)$
4. $\rho^2 = \rho.\rho$
5. $AK = sk.G_{Aff}$
6. If asset has associated $pk_T$, then ciphertext $C$ correctly encrypts $s$. Since $s \in \mathbb{Z}_p$ (belongs to scalar field of Pallas curve) and is large, 255-bit in our case, if its just encrypted in exponent-Elgamal, the descryption will be impractical since the decryptor ($pk_T$) has to solve discrete log of a 255-bit value.
   Thus prover breaks it into small chunks and encrypts each chunk using exponent-Elgamal encryption. These chunks are small enough so that discrete log over them can be completeled in reasonable time (few minutes). `CHUNK_BITS` denotes the bit size of each chunk and `NUM_CHUNKS` denotes the total number of chunks. In our implementation, `CHUNK_BITS` = 48 and `NUM_CHUNKS` = 6 since $\lceil {\frac{255}{48}} \rceil = 6$ and this means 6 chunks are sufficent to encode the 255-bit value
   Since Elgamal is homomorphic, these encryptions of chunks can be combined together to get an encryption of the whole $s$ which can then be used in a Sigma protocol to show its equality with the $s$ used in account state $State_0$


Following describes the protocol assuming a $pk_T$ exists but its simple to avoid corrsponding parts of the proof if asset does not have $pk_T$

**Instance**: $State_0, AK, at, c, N, id, C_i, pk_T, G_{Aff}, G_{Enc}, G_i, H_i$

**Witness**: $sk, \rho, s, s_{{chunks}_i}, r_{enc_i}$.

Above are the high level instance and witness values known before the protocol starts and don't include instance and witness created during protocol execution like the various blindings and $T$ values.

#### Prover
1. Prover first wants to prove knowledge of $\rho^2, s$ in the relation $\rho^2.G_5 + s.G_6 = State_0 - AK - at.G_3 - N - id.G_7$. This is just relation 1 from above rearranged where values on RHS are public. Lets call these $D$ as $D = State_0 - AK - at.G_3 - N - id.G_7$
   So prover wants to prove knowledge of $\rho^2, s$ in $\rho.G_4 + \rho^2.G_5 + s.G_6 = D$ and will do with a Sigma protocol
2. Prover picks random $\rho_{blinding}, \rho^2_{blinding}, s_{blinding} \in \mathbb{Z}_p$ and creates
   $T_{state} = \rho_{blinding}.G_4 + \rho^2_{blinding}.G_5 + s_{blinding}.G_6$
   $T_{null} = \rho.G_4$
3. If $pk_T$ exists, break randomness `s` in `NUM_CHUNKS` chunks and encrypt each chunk using exponent Elgamal as:
   $C_i = (C_{i,0}, C_{i,1}) = (r_{enc_i}.G_{Enc}, r_{enc_i}.pk_T + s_{{chunks}_i}.G), \quad C_i \in \mathbb{G}^2_p$
   where $C_i$ is ciphertext of i-th chunk, $s_{chunks}$ is the base-$2^{CHUNK\_BITS}$ representation of $s$ and it has `NUM_CHUNKS` digits and $r_{enc_i} \in \mathbb{Z}_p$ is the randomness for the encryption.
4. Note that
   $Com_s = \sum{{2^{CHUNK\_BITS}}^i.C_{i_1}} = \sum{{2^{CHUNK\_BITS}}^i.r_{enc_i}.pk_T} + s.G$
   $Com_r = \sum{{2^{CHUNK\_BITS}}^i.C_{i_0}} = \sum{{2^{CHUNK\_BITS}}^i.r_{enc_i}.G_{Enc}}$
   and the scalar multiple of $pk_T$ in $Com_s$ is same as the multiple of $G_{Enc}$ in $Com_r$ and that multiple of $G$ is $s$. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of both multiples:
   Pick random $r_{combined} \in \mathbb{Z}_p$ and reuse for $s$ and create $T_{r-combined} = r_{combined}.G_{Enc}, \quad T_{s-combined} = r_{combined}.pk_T + s_{blinding}.G$, where $T_{r-combined}, T_{s-combined} \in \mathbb{G}_p$
5. The prover also needs to prove that each $s_{{chunks}_i}$ is a `CHUNK_BITS`-bit value else it can create large values for $s_{{chunks}_i}$ which are valid base-$2^{CHUNK\_BITS}$ representation digits but are so large that can't be practically retrieved using discrete log solving algorithms. For this the prover uses Bulletproofs and enforces range proof constraints for each $s_{chunk_i}$
6. For proving knowledge of $r_{enc_i}, s_{{chunks}_i}$ the prover inializes Sigma protocols, 2 for each chunk. It first creates blindings and the commits to them as
   For $i$-th chunk, pick random $r_{enc-blinding_i}, s_{chunks-blinding_i} \in \mathbb{Z}_p$ and create $T_{{enc}_i} = r_{{enc-blinding}_i}.G_{Enc}, \quad T_{{chunks}_i} = r_{enc-blinding_i}.pk_T + s_{chunks-blinding_i}.G$, where $T_{enc_i}, T_{chunks_i} \in \mathbb{G}_p$
7. For proving $\rho = Poseidon2(sk, at||c)$ and $\rho^2 = \rho*\rho$, prover uses Bulletproofs constraints for Poseidon2 and a multiplication
8. Prover needs to prove that Bulletproofs constraints used in steps 5, and 7 do indeed enforce on $sk, s_{chunks_i}, \rho, \text{and}, \rho^2$. Prover uses Sigma protocol (Chaum Pedersen) to prove equality of committed values in Bulletproof's commitment (corresponding to its witnesses) and in $State_0, \text{and}, C_i$. Let $C_{BP_\rho}$ and $C_s$ be Bulletproof's commitments to these values:
   $C_{BP_\rho} = b.H_0 + sk.H_1 + \rho.H_2 + \rho^2.H_3, \in \mathbb{G}_p$
   $C_{BP_s} = b'.H_0 + s_{chunks_0}.H_1 + s_{chunks_1}.H_2 + ... +  s_{chunks_{NUM\_CHUNKS-1}}.H_{NUM\_CHUNKS}, \in \mathbb{G}_p$
   Here $b, b'$ are blindings to the commitment added by Bulletproof.
9. Prover proves knowledge of above committed values and equality of these with other commitments as:
   Pick random $r_{BP_\rho} \in \mathbb{Z}_p$ and $r_{BP_s} \in \mathbb{Z}_p$ and create
   $T_{BP_\rho} = r_{BP_\rho}.H_0 + sk_{blinding}.H_1 + \rho_{blinding}.H_2 + \rho^2_{blinding}.H_3, \in \mathbb{G}_p$
   $T_{BP_s} = r_{BP_s}.H_0 + s_{chunks-blinding_0}.H_1 + s_{chunks-blinding_1}.H_2 + ... + s_{chunks-blinding_{NUM\_CHUNKS-1}}.H_{NUM\_CHUNKS}, \in \mathbb{G}_p$
10. And to prove knowledge of secret key in its affirmation key $AK$, it picks random $sk_{blinding}$ and creates $T_{pk} = sk_{blinding}.G_{Aff}$
11. Prover hashes the following to create challenge $c$ as:
    $$c = Hash(State_0, AK, at, c, N, id, C_i, pk_T, Com_s, Com_r, C_{BP_\rho}, C_{BP_s}, T_{state}, T_{null}, T_{r-combined}, T_{s-combined}, T_{enc_i}, T_{chunks_i}, T_{BP_\rho}, T_{BP_s}, T_{pk})
    $$
12. Prover now creates responses for each sigma protocol as:
    $Resp_{state} = [\begin{matrix}
    \rho^2_{blinding} + \rho^2.c, & s_{blinding} + s.c\\
    \end{matrix}]$
    $Resp_{pk} = sk_{blinding} + sk.c$
    $Resp_{null} = \rho_{blinding} + \rho.c$
    $Resp_r = r_{combined} + \sum{{2^{CHUNK\_BITS}}^i.r_{enc_i}}.c$
    Note that since prover already created response for witness $s$ as $s_{blinding} + s.c$ in $Resp_{state}$, it has both responses for $Com_s$.
13. Creates responses for $C_i$:
    $Resp_{i,0} = r_{enc-blinding_i} + r_{enc_i}.c$
    $Resp_{s_{chunks_i}} = s_{chunks-blinding_i} + s_{chunks_i}.c$
    Note that $Resp_{i,0}$ is used as well for checking relation $C_{i, 1}$
14. For relations, $C_{BP_\rho}, C_{BP_s}$, only the responses for witnesses $b, b'$ need to be created as the responses of other witnesses are already created.
    $Resp_b = r_{BP_\rho} + b.c$
    $Resp_{b'} = r_{BP_s} + b'.c$
15. The proof is
    $$
    (C_{BP_\rho}, C_{BP_s}, T_{state}, T_{null}, T_{r-combined}, T_{s-combined}, T_{enc_i}, T_{chunks_i}, T_{BP_\rho}, T_{BP_s}, T_{pk}, Resp_{state}, Resp_{pk}, Resp_{null}, Resp_r, Resp_{i,0}, Resp_{s_{chunks_i}}, Resp_b, Resp_{b'})
    $$

#### Verifier

1. Verifier hashes the following to create challenge $c$ as:
   $$c = Hash(State_0, AK, at, c, N, id, C_i, pk_T, Com_s, Com_r, C_{BP_\rho}, C_{BP_s}, T_{state}, T_{null}, T_{r-combined}, T_{s-combined}, T_{enc_i}, T_{chunks_i}, T_{BP_\rho}, T_{BP_s}, T_{pk})
   $$
2. Enforces constraints in Bulletproof for Poseidon2 and a multiplication for $\rho$ generation and $\rho^2 = \rho.\rho$ respectively
3. Enforces constraints in Bulletproof for `NUM_CHUNKS` range proofs, one for each chunk.
4. Verifies correctness of $State_0$ by checking:
   $Resp_{state}[0].G_5 + Resp_{state}[1].G_6\stackrel{?}{=} T_{state} + State_0.c$
   $\implies$ $(\rho^2_{blinding} + \rho^2.c).G_5 + (s_{blinding} + s.c).G_6 \stackrel{?}{=} T_{state} + State_0.c$
5. Verifies correctness of $pk$ by checking:
   $Resp_{pk}.G_{Aff}\stackrel{?}{=} T_{pk} + AK.c$
   $\implies$ $(sk_{blinding} + sk.c).G_{Aff} \stackrel{?}{=} T_{pk} + AK.c$
6. Verifies correctness of $N$ by checking:
   $Resp_{null}.G_4 \stackrel{?}{=} T_{null} + N.c$
   $\implies$$(\rho_{blinding} + \rho.c).G_4 \stackrel{?}{=} T_{null} + N.c$
7. Verifier creates $Com_r$ and $Com_s$ as:
   $Com_r = \sum{{2^{CHUNK\_BITS}}^i.C_{i_0}}$
   $Com_s = \sum{{2^{CHUNK\_BITS}}^i.C_{i_1}}$
8. Verifies correctness of $Com_r$ by checking:
   $Resp_r.G_{enc} \stackrel{?}{=} T_{r-combined} + Com_r.c$
   $\implies$ $(r_{combined} + \sum{{2^{CHUNK\_BITS}}^i.r_{enc_i}}.c).G_{enc} \stackrel{?}{=} T_{r-combined} + Com_r.c$
9. Verifies correctness of $Com_s$ by checking:
   $Resp_r.pk_T + Resp_{state}[1].G \stackrel{?}{=} T_{s-combined} + Com_s.c$
   $\implies$ $(r_{combined} + \sum{{2^{CHUNK\_BITS}}^i.r_{enc_i}}.c).pk_T + (s_{blinding} + s.c).G \stackrel{?}{=} T_{s-combined} + Com_s.c$
10. Verifier checks response for $C_{i,0}$ as:
    $Resp_{i,0}.G_{Enc} \stackrel{?}{=} T_{enc_i} + C_{i,0}.c$
    $\implies$ $(r_{enc-blinding_i} + r_{enc_i}.c).G_{Enc} \stackrel{?}{=} T_{enc_i} + C_{i,0}.c$
11. Verifier checks response for $C_{i,1}$ as:
    $Resp_{i,0}.pk_T + Resp_{s_{chunks_i}}.G \stackrel{?}{=} T_{chunks_i} + C_{i,1}.c$  
    $\implies$ $(r_{enc-blinding_i} + r_{enc_i}.c).pk_T + (s_{chunks-blinding_i} + s_{chunks_i}.c).G \stackrel{?}{=} T_{chunks_i} + C_{i,1}.c$
12. Verifier checks response for $C_{BP_\rho}$ as:
    $Resp_b.H_0 + Resp_{pk}.H_1 + Resp_{null}.H_2 + Resp_{state}[0].H_3 \stackrel{?}{=} T_{BP_\rho} + C_{BP_\rho}.c$
    $\implies$ $(r_{BP_\rho} + b.c).H_0 + (sk_{blinding} + sk.c).H_1 + (\rho_{blinding} + \rho.c).H_2 + (\rho^2_{blinding} + \rho^2.c).H_3 \stackrel{?}{=} T_{BP_\rho} + C_{BP_\rho}.c$
13. Verifier checks response for $C_{BP_s}$ as:
    $Resp_{b'}.H_0 + Resp_{s_{chunks_0}}.H_1 + Resp_{s_{chunks_1}}.H_2 + ... + Resp_{s_{chunks_{NUM\_CHUNKS-1}}}.H_{NUM\_CHUNKS} \stackrel{?}{=} T_{BP_s} + C_{BP_s}.c$
    $\implies$ $(r_{BP_s} + b'.c).H_0 + (s_{chunks-blinding_0} + s_{chunks_0}).H_1 + (s_{chunks-blinding_1} + s_{chunks_1}).H_2 + ... + (s_{chunks-blinding_{NUM\_CHUNKS-1}} + s_{chunks_{NUM\_CHUNKS-1}}).H_{NUM\_CHUNKS} \stackrel{?}{=} T_{BP_s} + C_{BP_s}.c$
14. Verifier finally checks the Bulletproofs proof that verifies all constraints, i.e for Poseidon2, multiplication and range proofs

-----------------------------------------

