# Notation, Prerequisites and System Model

## Notation

We are working in 2-cycle elliptic curve groups $\mathbb{G}_p$ and $\mathbb{G}_q$ with orders $p$ and $q$ respectively.

$|\mathbb{G}_p| = p, |\mathbb{G}_q| = q$

The scalar field of $\mathbb{G}_p$ is $\mathbb{Z}_p$ and its base field is $\mathbb{Z}_q$. Conversely, the scalar field of $\mathbb{G}_q$ is $\mathbb{Z}_q$ and its base field is $\mathbb{Z}_p$. Thus coordinates of points in $\mathbb{G}_p$ are in $\mathbb{Z}_q$ and coordinates of points in $\mathbb{G}_q$ are in $\mathbb{Z}_p$.

The following are the group generators (curve points):

$G, G_i, H, H_i, J \in \mathbb{G}_p$

$\widetilde{G}, \widetilde{G}_i, \widetilde{H}, \widetilde{H}_i \in \mathbb{G}_q$

The generators $G, G_i, \widetilde{G}_i, H, H_i, J, \widetilde{H}, \widetilde{H}_i$ can be derived using a hash-to-curve method.

For a point $P$, the notations $P.x$ and $P.y$ refer to its $x$-coordinate and $y$-coordinate, respectively.

We use [Pallas](https://neuromancer.sk/std/other/Pallas/) and [Vesta](https://neuromancer.sk/std/other/Vesta) as the curves. The group $\mathbb{G}_p$ refers to the group of points on the Pallas curve, and the group $\mathbb{G}_q$ refers to the group of points on the Vesta curve.  Thus $G, G_i$ are generators of the Pallas curve and $\widetilde{G}, \widetilde{G}_i$ are generators of the Vesta curve.
But any 2 curves with a 2-cycle can be used.

For any sequence $S$, $S[i]$ represents the item at the $i$-th index. $S[0]$ is the first item, $S[1]$ is the second item, and so on.

## Prerequisites

### Sigma protocol

For proving knowledge and equality of committed values in Pedersen commitments, we use [Sigma protocols](https://www.cs.au.dk/~ivan/Sigma.pdf).

Consider the following commitment to witnesses $\{w_1, ..., w_n\}$ and randomness $r$

$$
C = r.G + \sum_{i=1}^n w_i.G_i
$$

To prove knowledge of witnesses, following protocol is executed

**Protocol**
1. Prover selects random values $r_T, w_{i,T} \in \mathbb{Z}_p$ and computes $T$ as:
   $$
   T = r_T.G + \sum_{i=1}^n w_{i,T}.G_i
   $$
2. The prover hashes $C$ and $T$ to get a challenge $e \in \mathbb{Z}_p$
3. Prover creates responses $s = \{s_r, s_1, ..., s_n\}$ as
   $$
   s_r = r_T + e.r, \quad s_i = w_{i,T} + e.w_i
   $$
4. Verifier checks the proof by checking the response ($s_i$) relations in the exponent as
   $$
   e.C + T \stackrel{?}{=} s_r.G + \sum_{i=1}^n s_i.G_i
   $$


### Chaum-Pedersen Proof of Equality for Shared Witnesses

This protocol proves that a subset of $k$ witnesses are shared between two generalized commitments, $C_A$ and $C_B$ ($w_i = w'_i$ for $i=1, ..., k$).

The Prover knows the following for $C_A$ and $C_B$ 
$$
\{r_A, \{w_i\}_{i=1}^k, \{w_j\}_{j=k+1}^m\} \text{ for } C_A
$$
$$
\{r_B, \{w'_i\}_{i=1}^k, \{w'_l\}_{l=k+1}^p\} \text{ for } C_B
$$

where the witnesses $\{w_i\}_{i=1}^k$ and $\{w'_i\}_{i=1}^k$ are the same.

$$
C_A = r_A . G_A + \sum_{i=1}^k w_i . G_i + \sum_{j=k+1}^m w_j . G_j
$$
$$
C_B = r_B . G_B + \sum_{i=1}^k w'_i . G'_i + \sum_{l=k+1}^p w'_l . G'_l
$$

**Protocol**
1. Prover picks common random $w_{i,T}$ for the common witnesses $w_i$. It selects other randoms for the other components ($r_{A,T}, r_{B,T}, w_{j,T}, w'_{l,T}$). It computes $T_A$ and $T_B$:
$$
T_A = r_{A,T} . G_A + \sum_{i=1}^k w_{i,T} . G_i + \sum_{j=k+1}^m w_{j,T} . G_j
$$
$$
T_B = r_{B,T} . G_B + \sum_{i=1}^k w_{i,T} . G'_i + \sum_{l=k+1}^p w'_{l,T} . G'_l
$$
2. The prover hashes $C_A$, $C_B$, $T_A$, $T_B$ to get a challenge $e \in \mathbb{Z}_p$
3. Prover computes the common response set $\mathbf{s}_{common} = \{s_i\}_{i=1}^k$ for the common witnesses, and the unique responses for the remaining witnesses.

Common responses
$$
s_i = w_{i,T} + e.w_i \quad \text{for } i=1, ..., k
$$

Remaining responses for $C_A$:
$$
s_{A,r} = r_{A,T} + e.r_A, s_j = w_{j,T} + e.w_j \quad \text{for unique } j=k+1, ..., m
$$

Remaining responses for $C_B$:

$$
s_{B,r} = r_{B,T} + e . r_B, s'_l = w'_{l,T} + e . w'_l \quad \text{for unique } l=k+1, ..., p
$$

4. The Verifier accepts the proof if and only if both verification equations hold. The Verifier must use the same submitted response $s_i$ for the common witnesses components in both checks:

Verification for $C_A$:

$$
e.C_A + T_A \stackrel{?}{=} s_{A,r}.G_A + \sum_{i=1}^k s_i.G_i + \sum_{j=k+1}^m s_j.G_j
$$



Verification for $C_B$:

$$
e.C_B + T_B \stackrel{?}{=} s_{B,r}.G_B + \sum_{i=1}^k s_i.G'_i + \sum_{l=k+1}^p s'_l.G'_l
$$


_The challenge generation using Fiat-Shamir can optionally include application-specific context information to avoid replay 
attacks across different contexts. This context/nonce is used in all the proofs in the implementation but are omitted in 
this documentation._

### Elgamal encryption and its variations

**Elgamal**
For ElGamal on $G_p$, a message $M \in \mathbb{G}_P$ is encrypted under a Public Key $EK(=ek.G)$ as ciphertext $C=(C_1, C_2)$ where $C_1, C_2 \in G_p$.
To encrypt, select random ephemeral key $r \in \mathbb{Z}_p$ and then
$$
C = (C_1, C_2) \quad \text{where} \quad C_1 = r.G \quad \text{and} \quad C_2 = M + r.EK
$$
To decrypt, using secret key $ek$, get $M = C_2 - ek.C_1$.
This variation is used to encrypt public keys.

**Exponent Elgamal**
For ElGamal on $G_p$, a message $m \in \mathbb{Z}_p$ is encrypted under a Public Key $EK(=ek.G)$ as ciphertext $C=(C_1, C_2)$ where $C_1, C_2 \in G_p$.
To encrypt, select random ephemeral key $r \in \mathbb{Z}_p$ and then
$$
C = (C_1, C_2) \quad \text{where} \quad C_1 = r.G \quad \text{and} \quad C_2 = m.G + r.EK
$$
To decrypt, using secret key $ek$, get $m.G = C_2 - ek.C_1$. Now solve for discrete log $m$ in $m.G$
This variation is used to encrypt small values like account balance, transaction amount, asset id, etc.

**Twisted Elgamal**
This variant is more useful (efficient and guarantees) when the same message is supposed to be encrypted for multiple public keys. Say the same message $M \in \mathbb{G}_P$ is to be encrypted for 2 public keys $EK_1$ and $EK_2$ with twisted Elgamal.
To encrypt, select random ephemeral key $r \in \mathbb{Z}_p$ and then
$$
C = (C_1, C_2, C_3) \quad \text{where} \quad C_1 = r.EK_1, \quad C_2 = r.EK_2 \quad \text{and} \quad C_3 = M + r.G
$$

To decrypt, using secret key $ek_1$,  get $M = C_3 - ek_1^{-1}.C_1$.

To decrypt, using secret key $ek_2$,  get $M = C_3 - ek_2^{-1}.C_2$.

Note that ciphertext $C$ has 3 elements and not 4 like regular Elgamal. In general, with twisted Elgamal for $n$ parties, ciphertext has $n+1$ elements but each party works only 2 elements.
Twisted Elgamal applies to exponent Elgamal similarly.

### Curve Trees

We use [Curve Trees](https://eprint.iacr.org/2024/1647) as accumulator that support zero knowledge proofs of membership. Think of them like merkle trees where the hash function is the non-hiding Pedersen commitment. Conceptually, the tree is created as follows:

Assume its a binary tree. The leaf of the tree are always group element, elliptic curve points in our case.
Say $P_0, P_1$ are 2 leaves, then their parent node $Q$ is a non-hiding (no randomness) commitment to x-coordinates of $P_0, P_1$ as $Q = G_0 * P_0.x + G_1 * P_1.x$.
Then to form the parent of node $R$ from $Q$ and its  siblings, the same process is followed with x-coordinates of $Q$ and its siblings but this time the generators used are $\widetilde{G}_0, \widetilde{G}_1$ as $R = \widetilde{G}_0 * Q_0.x + \widetilde{G}_1 * Q_1.x$. This is because $P_0.x, P_1.x$ and $Q_0.x, Q_1.x$ are in different groups and for this reason, we need a cycle of curves.
Because of the homomorphic property of the curve tree hash function (commitment), updates to the curve tree are very efficient.

The curve tree membership proof contains nodes (commitments) on the path from root to the leaf but these nodes are *randomized*, i.e. a blinding value is added to the commitment to make it a hiding commitment. So in the above example, the proof for say leaf $P_0$ would contain nodes $[P_0', Q_0', ...]$ where $P_0' = P_0 + G * r_0$, $Q_0' = Q_0 + \widetilde{G} * r_1$ and so on where $[P_0, Q_0, ...]$ are the leaf $P_0$'s path from leaf ($P_0$) to root.

In implementation, a public element $\Delta$ is added to a point before taking its x-coordinate and the curve tree paper explains why then taking x-coodinate is sufficient. Also, we don't use a binary tree but much larger arity like 512, 1000 or 2000


### Bulletproofs

We use Bulletproofs as a zk-SNARK and the curve tree membership proof is expressed using R1CS circuit. We also express range proofs and some other relations as R1CS circuit. One of the benefit of using Bulletproofs is that it allows Commit-and-Prove (CP) SNARKs meaning in addition to the proof, we also get Pedersen commitments to the desired witnesses. This helps us bridge (with the Pedersen commitment) Sigma protocols and zk-SNARK proof, meaning we can ensure that certain Sigma protocol is executing over the same witness(es) as the zk-SNARK.


## System model
The system has few kinds of entities:

1. Investors: These have accounts per asset and send transactions to transfer assets from their accounts or receive assets in their accounts. Each investor maintains two key pairs: an encryption key and an affirmation key. Both public keys are elements of the Pallas curve $G_p$ and are derived from their respective secret keys. We use distinct generators $G_{Enc}$ and $G_{Aff}$ from $\mathbb{G}_p$.
   - Encryption keys: secret key $ek \in \mathbb{Z}_p$ and public key $EK = ek.G_{Enc}$ with $EK \in \mathbb{G}_p$
   - Affirmation keys: secret key $sk \in \mathbb{Z}_p$ and public key $AK = sk.G_{Aff}$ with $AK \in \mathbb{G}_p$
   
   For each investor, the chain also knows its identity $ID$ where an $ID$ can have any number of encryption and affirmation keys associated to it.
2. Auditors: These parties are tied to specific assets and they are supposed to be able to view all transactions for those assets. They only have an encryption key as $(ek, EK=ek.G_{Enc})$. An asset may have 0 or more auditors.
3. Mediators: These parties are also tied to specific assets and they are supposed to be able to view and accept or reject all transactions for those assets. They have both encryption and affirmation keys. An asset may have 0 or more mediators.

The encryption key is only used to decrypt the transactions while affirmation keys are used to act on transactions, like approving/disapproving deposit or withdraw. Note that all public keys are in the Pallas curve.


### Assets
Each asset has a unique numeric id and an asset can have 32 bits max and thus its maximum value is $2^{32} - 1$. These are known in code as $ASSET\_ID\_BITS$ and $MAX\_ASSET\_ID$. Each asset has an issuer which can mint that asset into its account and the chain tracks the asset issuer by its public key. The maximum total supply any asset can have is 48 bits, i.e. $2^{48} - 1$. These are known in code as $BALANCE\_BITS$ and $MAX\_BALANCE$.
There are 2 types of assets, ones which can be used to pay transaction fee and the rest which cant be used for fee.
Each asset can have 0 or more auditors or mediators.
Each asset can optionally have 1 trustee whose public key is $pk_T \in \mathbb{G}_p$. This entity is responsible for helping with key recovery, clawback of funds, reversal of txns etc. An account while registering for an asset that has a trustee has to encrypt certain information from his account for $pk_T$. The trustee does need the help of auditor/mediator to do these actions.


### Accounts and Settlements
Contrary to many other anonymous cryptocurrencies, DART works on account model rather than UTXO. This is because we want users to prove their exact account balance and not be able to hide any of it

Also, in DART assets can't be transferred unilaterally as the receiver of the asset has to agree to receive as well. An exception is portfolio move, where assets are moved between accounts with the same identity.

Each investor can have only 1 account per asset id and it can be seen as a pair $(pk, asset\_id)$. As accounts participate in transactions, their state changes. An account state is a Pedersen commitment in the Pallas curve and the $i$-th account state is:
$$
State_i = sk.G_{Aff} + balance.G_1 + counter.G_2 + asset\_id.G_3 + \rho.G_4 + \rho^{i+2}.G_5 + s^{2^i}.G_6 + id.G_7, \quad State_i \in \mathbb{G}_p
$$
where

- $sk$ - the secret key for their affirmation public key
- $id$ - their identity $ID$, to which all their public keys are associated
- $asset\_id$ - id of the asset for which the account is
- $balance$ - the current account balance
- $counter$ - This is number >= 0 and it can change during various transactions
- $\rho$ - This is the initial nullifier secret key created during registration.
- $\rho^{i+2}$ - This is the nullifier secret key for this state and used when revealing the nullifier for this state. The rationale for exponent ${i+2}$ will be given in a later section.
- $s$ - the randomness of the commitment. The rationale for $s^{2^i}$ will be given in a later section.


#### Account state transitions
For updating account state from $State_i$ to $State_{i+1}$, $State_i$ must be invalidated by revealing a **nullifier** $N = \rho^{i+2}.G_5$. The chain records $N$ in a set and does not allow to reveal the same nullifier twice, thus preventing multiple new state transitions from the same old state. The new state will be:
$$State_{i+1} = sk.G_{Aff} + balance'.G_1 + counter'.G_2 + asset\_id.G_3 + \rho.G_4 + \rho^{i+3}.G_5 + s^{2^{i+1}}.G_6 + id.G_7, \quad State_i \in \mathbb{G}_p$$
Note that in the new state $State_{i+1}$, fields $sk, asset\_id, \rho, id$ don't change. For invalidating state $State_{i+1}$ (to transition to $State_{i+2}$), nullifier will be $\rho^{i+3}.G_5$.

During state transition from $State_i$ to $State_{i+1}$, $State_i$ must not be revealed as it allows tracking the investor. $State_{i+1}$ however is revealed.

To allow for certain operations like key recovery, clawback of funds etc, the nullifier secret key $\rho^i$ and randomness $s$ are created for each state in a particular way. Each new account state is supposed to have the exponent of $\rho$ 1 more than the previous state's exponent of $\rho$ and the randomness of new state is supposed to square of the randomness of previous state.

The starting state of an account is (balance and counter are 0 in initial state)
$$
State_0 = sk.G_{Aff} + 0.G_1 + 0.G_2 + asset\_id.G_3 + \rho.G_4 + \rho^2.G_5 + s.G_6 + id.G_7
$$

Then the next state is
$$
State_1 = sk.G_{Aff} + balance_1.G_1 + counter_1.G_2 + asset\_id.G_3 + \rho.G_4 + \rho^3.G_5 + s^2.G_6 + id.G_7
$$

The next state
$$
State_2 = sk.G_{Aff} + balance_2.G_1 + counter_2.G_2 + asset\_id.G_3 + \rho.G_4 + \rho^4.G_5 + s^4.G_6 + id.G_7
$$


The nullifier secret keys form these powers $\rho^2, \rho^3, \rho^4, ...$ and randomness forms these powers $s, s^2, s^4, s^8, ...$ and anyone knowing $rho$ or $s$ can predict subsequent values. The reason for not constructing nullifier secret key $\rho^i$ as $\rho^2, \rho^4, \rho^8$ is because $\rho^i.G_5$ is revealed which reduces security if squares are used (TODO: Link paper and add details).
During account registration, i.e. creating $State_0$, if asset has a trustee, then the value $s$ is encrypted for $pk_T$ and published on chain.

#### Settlements
Asset transfers in DART are done through settlements. A settlement is a transfer of 1 or more assets between 2 or more accounts. A settlement lifecyle for transfer of a single asset from party (account) $A$ to $B$ is typically like this:

1. An entity creates a settlement stating: transfer 10 units of asset-id $at$ from $A$ to $B$.
2. If party $A$ agrees, it will send an affirmation txn to the chain. This involves $A$ to change its account state such that its $balance$ is decreased by 10 units, $counter$ is increased by 1, and few other changes as well. A proof that the state has been correctly updated is also sent to the chain. This step will nullify (invalidate) the previous state of account $A$ and set this new state as the current active state.
3. If party $B$ also agrees, it will also send an affirmation txn to the chain along its new state where the $counter$ is increased by 1, and some more changes and the proof that the state change is correct. Similar to above, this step will nullify (invalidate) the previous state of account $B$ and set this new state as the current active state.

Note that the chain does not learn asset-id $at$ or amount of 10 units or any details of accounts $A$ and $B$ like their public keys, identity, counter, balance, etc. But the integrity of these are enforced through zero-knowledge proofs.

Above example is just 1 variation of a settlement but settlements can be more involved. Also detailed explanation of state changes and proofs follow in subsequent sections.

#### Fee account
The above description of account states is for assets which are not used in paying fee. For fee payment asset-ids, the account state is simpler as:
$$
State_i = sk.G_{Aff} + balance.G_1 + asset\_id.G_3 + \rho.G_5 + s.G_6, \quad State_i \in \mathbb{G}_p
$$

Reason for this simplicity will be given later.

The state is a Pedersen commitment in a cyclic group. Similar to above, the account state's witnesses don't have counter and "age" components.

For updating account state from $State_i$ to $State_{i+1}$, $State_i$ must be invalidated by revealing a **nullifier** $N = \rho.G_5$. Similar to above, the chain records $N$ in a set and does not allow to reveal the same nullifier twice. The new state will be: $$State_{i+1} = sk.G_{Aff} + balance'.G_1 + asset\_id.G_3 + \rho'.G_5 + s'.G_6, \quad State_i \in \mathbb{G}_p$$
Note that in the new state $State_{i+1}$, fields $sk, asset\_id$ don't change but new $\rho', s'$ are sampled randomly.


### Accumulators
The system uses curve trees as accumulator and has 3 curve trees.

1. Asset curve tree: Each leaf of this tree corresponds to an asset and stores the $asset\_id$ and the public keys of its auditors and mediators. When issuers register a new asset, a new leaf is added to this tree. When they update existing asset, their leaf is updated accordingly.
   A leaf of the asset tree is a group element in $\mathbb{G}_q$ and thus a point on Vesta curve. It is Pedersen commitment to the "asset-id" and x-coordinates of the public keys of auditors and mediators as: 
   $$Leaf_{asset\_id} = (AT.x).\widetilde{G} + (EK_1.x).\widetilde{G}_1 + (EK_2.x).\widetilde{G}_2 + ... + (EK_n.x).\widetilde{G}_n, \quad Leaf_{asset\_id} \in \mathbb{G}_q$$
   Here
   - $(AT.x)$ refers to taking the x-coordinate of point $AT = asset\_id.J \quad A \in \mathbb{G}_p$
   - $(EK_i.x)$ refers to taking the x-coordinate of public key $EK_i$ of the $i$-th auditor/mediator. 
     The x-coordinates are taken using the same approach as done by curve tree paper: adding a public element $\Delta$ to $EK_i$ and taking the x-coordinate of the result
2. Fee account curve tree: Each leaf of this tree corresponds to an account state for a fee paying asset. As fee payments are done, existing states of those accounts are invalidated by revealing the nullifier (more on that later) and new states are added. A leaf of this tree is an account state as:
   
   $$
   Leaf_i = sk.G_{Aff} + balance.G_1 + asset\_id.G_3 + \rho.G_5 + s.G_6, \quad Leaf_i \in \mathbb{G}_p
   $$
   
   This is an append only tree and leaves once added are never removed. And states of all fee paying accounts regardless of the asset-id are captured in this tree.
3. Main account curve tree: Each leaf of this tree corresponds to an account state for a non-fee paying asset. As corresponding transactions are done, existing states of those accounts are invalidated by revealing the nullifier (more on that later) and new states are added. A leaf of this tree is an account state as:
   
   $$
   Leaf_i = sk.G_{Aff} + balance.G_1 + counter.G_2 + asset\_id.G_3 + \rho.G_4 + \rho^{i+2}.G_5 + s^{2^i}.G_6 + id.G_7, \quad Leaf_i \in \mathbb{G}_p
   $$
   This is also an append only tree and leaves once added are never removed. And states of all non-fee paying accounts regardless of the asset-id are captured in this tree.

Reason for having 2 separate trees of different accounts is given later.

### Asset-account mapping
The chain allows 1 public key to have only 1 account per asset-id. This is done by a Asset-account registration step where the account's public key and asset-id are revealed and the chain keeps them in a mapping disallowing that public key to register for the same asset-id again. 
This is to ensure that a public key can do an accurate proof-of-balance for that asset without hiding any amount of that asset. In future, we might support asset-id privacy during registration by the chain keeping a commitment of the assets per public key 
and during registration, a proof of uniqueness of the new asset-id against the committed set is provided (likely using a linear cost non-membership proof).

----------------------------------------
