use std::collections::HashMap;

use curve_tree_relations::curve_tree::{Root, SelRerandParameters};
use curve_tree_relations::curve_tree_prover::CurveTreeWitnessPath;

use super::*;

pub mod sync_tree;
use sync_tree::CurveTreeWithBackend;

#[cfg(feature = "async_tree")]
pub mod async_tree;

pub mod backends;

mod common;

pub type CurveTreeParameters = SelRerandParameters<PallasParameters, VestaParameters>;
pub type CurveTreeRoot<const L: usize> = Root<L, 1, PallasParameters, VestaParameters>;
pub type CurveTreePath<const L: usize> = CurveTreeWitnessPath<L, PallasParameters, VestaParameters>;

/// A trait for looking up paths in a curve tree.
pub trait CurveTreeLookup<const L: usize> {
    /// Returns the path to a leaf in the curve tree by its index.
    fn get_path_to_leaf_index(&self, leaf_index: u64) -> Result<CurveTreePath<L>>;

    /// Returns the path to a leaf in the curve tree by its value.
    fn get_path_to_leaf(&self, leaf: PallasA) -> Result<CurveTreePath<L>>;

    /// Returns the parameters of the curve tree.
    fn params(&self) -> &CurveTreeParameters;

    /// Returns the root node of the curve tree.
    fn root_node(&self) -> Result<CurveTreeRoot<L>>;
}

/// Check if the tree root is valid.
///
/// This allows verifying proofs against older tree roots.
pub trait ValidateCurveTreeRoot<const L: usize> {
    /// Validates the root of the curve tree.
    fn validate_root(&self, root: &CurveTreeRoot<L>) -> bool;

    /// Returns the parameters of the curve tree.
    fn params(&self) -> &CurveTreeParameters;
}

pub struct RootHistory<const L: usize> {
    roots: Vec<CurveTreeRoot<L>>,
    history_length: usize,
    params: CurveTreeParameters,
}

impl<const L: usize> RootHistory<L> {
    /// Creates a new instance of `RootHistory` with the given history length and parameters.
    pub fn new(history_length: usize, params: &CurveTreeParameters) -> Self {
        Self {
            roots: Vec::with_capacity(history_length),
            history_length,
            params: params.clone(),
        }
    }

    /// Adds a new root to the history.
    pub fn add_root(&mut self, root: CurveTreeRoot<L>) {
        if self.roots.len() >= self.history_length {
            self.roots.remove(0);
        }
        self.roots.push(root);
    }
}

impl<const L: usize> ValidateCurveTreeRoot<L> for &RootHistory<L> {
    fn validate_root(&self, root: &CurveTreeRoot<L>) -> bool {
        self.roots.contains(root)
    }

    fn params(&self) -> &CurveTreeParameters {
        &self.params
    }
}

pub struct FullCurveTree<const L: usize> {
    tree: CurveTreeWithBackend<L, 1, PallasParameters, VestaParameters>,
    params: CurveTreeParameters,
}

impl<const L: usize> std::fmt::Debug for FullCurveTree<L> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FullCurveTreeStorage")
            .field("tree", &self.tree)
            .finish()
    }
}

impl<const L: usize> FullCurveTree<L> {
    /// Creates a new instance of `FullCurveTree` with the given height and generators length.
    pub fn new_with_capacity(height: usize, gens_length: usize) -> Result<Self> {
        let params = SelRerandParameters::new(gens_length, gens_length);
        Ok(Self {
            tree: CurveTreeWithBackend::new(height, &params)?,
            params,
        })
    }

    pub fn height(&self) -> usize {
        self.tree.height()
    }

    /// Insert a new leaf into the curve tree.
    pub fn insert(&mut self, leaf: PallasA) -> Result<usize> {
        self.tree.insert_leaf(leaf.into(), &self.params)
    }

    /// Updates an existing leaf in the curve tree.
    pub fn update(&mut self, leaf: PallasA, leaf_index: usize) -> Result<()> {
        self.tree.update_leaf(leaf_index, leaf.into(), &self.params)
    }

    /// Returns the path to a leaf in the curve tree by its index.
    pub fn get_path_to_leaf_index(&self, leaf_index: usize) -> Result<CurveTreePath<L>> {
        Ok(self
            .tree
            .get_path_to_leaf(leaf_index, 0, &self.params)
            .unwrap())
    }

    /// Returns the parameters of the curve tree.
    pub fn params(&self) -> &CurveTreeParameters {
        &self.params
    }

    /// Get the root node of the curve tree.
    pub fn root_node(&self) -> CurveTreeRoot<L> {
        self.tree.root_node(&self.params).unwrap()
    }
}

/// A Curve Tree for the Verifier in the Dart BP protocol.
///
/// This tree is used to verify the commitments and proofs generated by the Prover.
///
/// It is a lean version of the curve tree, which means it does not store the full tree structure,
pub struct VerifierCurveTree<const L: usize> {
    tree: CurveTreeWithBackend<L, 1, PallasParameters, VestaParameters>,
    params: CurveTreeParameters,
}

impl<const L: usize> VerifierCurveTree<L> {
    /// Creates a new instance of `VerifierCurveTree` with the given height and generators length.
    pub fn new(height: u8, gens_length: usize) -> Result<Self> {
        let params = SelRerandParameters::new(gens_length, gens_length);
        Ok(Self {
            tree: CurveTreeWithBackend::new(height as usize, &params)?,
            params,
        })
    }

    /// Insert a new leaf into the curve tree.
    pub fn insert(&mut self, leaf: PallasA) -> Result<usize> {
        self.tree.insert_leaf(leaf.into(), &self.params)
    }

    /// Returns the parameters of the curve tree.
    pub fn params(&self) -> &CurveTreeParameters {
        &self.params
    }

    /// Get the root node of the curve tree.
    pub fn root_node(&self) -> Result<CurveTreeRoot<L>> {
        self.tree.root_node(&self.params)
    }
}

/// A Curve Tree for the Prover in the Dart BP protocol.
pub struct ProverCurveTree<const L: usize> {
    tree: CurveTreeWithBackend<L, 1, PallasParameters, VestaParameters>,
    leaf_to_index: HashMap<PallasA, u64>,
    params: CurveTreeParameters,
}

impl<const L: usize> ProverCurveTree<L> {
    /// Creates a new instance of `ProverCurveTree` with the given height and generators length.
    pub fn new(height: u8, gens_length: usize) -> Result<Self> {
        let params = SelRerandParameters::new(gens_length, gens_length);
        Ok(Self {
            tree: CurveTreeWithBackend::new(height as usize, &params)?,
            params,
            leaf_to_index: HashMap::new(),
        })
    }

    /// Insert a new leaf into the curve tree.
    pub fn insert(&mut self, leaf: PallasA) -> Result<u64> {
        let leaf_index = self.tree.insert_leaf(leaf.into(), &self.params)? as u64;
        self.leaf_to_index.insert(leaf, leaf_index);
        Ok(leaf_index)
    }

    /// Apply updates to the curve tree by inserting multiple untracked leaves.
    pub fn apply_updates(&mut self, leaves: Vec<PallasA>) -> Result<()> {
        for leaf in &leaves {
            self.tree.insert_leaf(leaf.into(), &self.params)?;
        }
        Ok(())
    }
}

impl<const L: usize> CurveTreeLookup<L> for &ProverCurveTree<L> {
    fn get_path_to_leaf_index(&self, leaf_index: u64) -> Result<CurveTreePath<L>> {
        Ok(self
            .tree
            .get_path_to_leaf(leaf_index as usize, 0, &self.params)?)
    }

    fn get_path_to_leaf(&self, leaf: PallasA) -> Result<CurveTreePath<L>> {
        if let Some(&leaf_index) = self.leaf_to_index.get(&leaf) {
            self.get_path_to_leaf_index(leaf_index)
        } else {
            Err(Error::LeafNotFound(leaf))
        }
    }

    fn params(&self) -> &CurveTreeParameters {
        &self.params
    }

    fn root_node(&self) -> Result<CurveTreeRoot<L>> {
        self.tree.root_node(&self.params)
    }
}
